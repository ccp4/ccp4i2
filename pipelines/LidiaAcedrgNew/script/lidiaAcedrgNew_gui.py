from __future__ import print_function

"""
    lidiaAcedrg_gui.py
    Copyright (C) 2015 Newcastle University
    Author: Martin Noble
    
    """

from PySide2 import QtGui, QtWidgets,QtCore
import os
from qtgui.CCP4TaskWidget import CTaskWidget
import gemmi

#-------------------------------------------------------------------
class lidiaAcedrgNew_gui(CTaskWidget):
    #-------------------------------------------------------------------
    TASKMODULE = 'ligands'       # Where this plugin will appear on the gui
    TASKTITLE = 'Make Ligand - AceDRG'     # A short title for gui menu
    DESCRIPTION = 'Generate a PDB file and dictionary (acedrg) from MOL file, SMILES string/file, or sketch (lidia).<br>Optionally match atom names to known structures.'
    TASKVERSION = 0.1
    TASKNAME = 'LidiaAcedrgNew'
    RANK=1

    def drawContents(self):
        indent = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'
        
        self.openFolder(folderFunction='inputData')
        
        self.createLine ( [ 'advice',' '] )
        self.createLine ( [ 'advice',' '] )
        
        self.createLine(['subtitle','Start point'])
        self.openSubFrame( frame=[True])
        self.createLine ( [ 'label','Start with molecular structure from ','stretch','widget','MOLSMILESORSKETCH' ] )
        
        self.createLine ( [ 'advice', 'Will launch Lidia to sketch molecule. Click Apply <b>and</b> Close in Lidia when sketch is ready.' ], toggle=['MOLSMILESORSKETCH','open',['SKETCH']])
        self.createLine ( [ 'advice', 'Optionally can provide a starting monomer for the Lidia sketch:' ], toggle=['MOLSMILESORSKETCH','open',['SKETCH']])
        
        self.createLine ( [ 'widget','MOLIN' ], toggle=['MOLSMILESORSKETCH','open',['SKETCH','MOL']] )
        self.createLine ( [ 'widget','MOL2IN' ], toggle=['MOLSMILESORSKETCH','open',['MOL2']] )
        
        self.createLine ( [ 'widget', '-guiMode', 'multiLine', 'SMILESIN' ] , toggle=['MOLSMILESORSKETCH','open',['SMILES']])
        self.createLine ( [ 'label', 'SMILES file', 'widget', 'SMILESFILEIN' ] , toggle=['MOLSMILESORSKETCH','open',['SMILESFILE']])
        self.createLine ( [ 'widget', 'DICTIN2' ] , toggle=['MOLSMILESORSKETCH','open',['DICT']])
        self.connectDataChanged('DICTIN2', self.updateTLC)
        self.createLine ( [ 'widget', 'PDBMMCIFIN' ] , toggle=['MOLSMILESORSKETCH','open',['PDBMMCIF']])
        self.connectDataChanged('PDBMMCIFIN', self.updateTLC)
        self.createLine ( [ 'label', '<i>Specified PDB/mmCIF file must contain only one monomer including hydrogen atoms.</i>' ] , toggle=['MOLSMILESORSKETCH','open',['PDBMMCIF']])
        self.createLine ( [ 'widget', 'TOGGLE_METAL', 'label' , 'This monomer contains a metal atom.' ] )
        self.connectDataChanged('controlParameters.TOGGLE_METAL', self.ToggleShowContainsMetal)
        self.createLine ( [ 'label', indent + 'Provide a relevant structure model in complex with this monomer to get ideal bond angles in the output:'] , toggleFunction=[self.ToggleShowContainsMetal, ['controlParameters.TOGGLE_METAL']])
        self.createLine ( [ 'label', indent, 'widget', 'METAL_STRUCTURE'] , toggleFunction=[self.ToggleShowContainsMetal, ['controlParameters.TOGGLE_METAL']])
        self.closeSubFrame()

        self.createLine(['subtitle', 'Output monomer'])
        self.openSubFrame( frame=[True])
        self.createLine ( [ 'label', 'Monomer code (usually 3 or 5 characters)','stretch','widget','TLC' ])
        self.createLine ( [ 'label', '<i>Note: These codes can be used for new monomers during structure determination: LIG, DRG, INH, 01 - 99.</i>'] )
        self.closeSubFrame()

        self.createLine(['subtitle','Advanced'] )
        self.openSubFrame( frame=[True] )
        """
        self.createLine(['advice','Geometry restraints *always* taken from ACEDRG'])
        self.createLine(['label','Output conformers generated by','stretch','widget','CONFORMERSFROM'])
        self.openSubFrame( frame=[False], toggle=['CONFORMERSFROM','open',['RDKIT']] )
        """
        self.createLine ( [ 'widget', 'USE_COORD', 'label', 'Use the coordinates from the input file for further optimisation (requires a reasonable input conformation)' ],
                          toggle=['MOLSMILESORSKETCH','open',['MOL','MOL2','DICT','PDBMMCIF']] )
        self.connectDataChanged('USE_COORD', self.useCoord)
        self.createLine ( [ 'widget','TOGGLE_NRANDOM','label','Set number of initial conformers to try:','stretch','widget','NRANDOM' ] )
        self.createLine ( [ 'widget', 'NOPROT', 'label' , 'No further protonation/deprotonation to be done by AceDRG' ] )
        self.closeSubFrame()

        try:
            import ccp4srs
            dummy = ccp4srs.Graph()
            self.createLine(['subtitle','Atom Naming'])
            self.openSubFrame( frame=[True])
            self.createLine ( [ 'label','Attempt to match atom names with ','stretch','widget','ATOMMATCHOPTION' ] )
            self.createLine ( [ 'label','Monomer code to match atom names with','stretch','widget','MATCHTLC' ], toggle=['ATOMMATCHOPTION','open',['MONLIBCODE']])
            self.createLine ( [ 'label','User supplied dictionary to match atom names with','stretch' ], toggle=['ATOMMATCHOPTION','open',['LOCALDICT']])
            self.createLine ( [ 'widget','DICTIN' ], toggle=['ATOMMATCHOPTION','open',['LOCALDICT']])
            self.closeSubFrame()
        except:
            print("Atom naming requires more recent version of ccp4srs-python")


    def isValid(self):
        invalidElements = super(lidiaAcedrgNew_gui, self).isValid()
        if self.container.inputData.MOLSMILESORSKETCH.__str__() == 'SMILES':
            self.container.inputData.MOLIN.unSet()
        return invalidElements


    def updateTLC(self):
        tlc = None
        try:
            if self.container.inputData.MOLSMILESORSKETCH == "DICT":
                blocks = gemmi.cif.read(str(self.container.inputData.DICTIN2.fullPath))
                for block in blocks:
                    tlc = block.find_value('_chem_comp.three_letter_code')
                    if tlc:
                        break
                    tlc = block.find_value('_chem_comp.id')
                    if tlc:
                        break
            elif self.container.inputData.MOLSMILESORSKETCH == "PDBMMCIF":
                st = gemmi.read_structure(str(self.container.inputData.PDBMMCIFIN.fullPath))
                # lookup = {x.atom: x for x in st[0].all()}
                # tlc = list(lookup.values())[0].residue.name
                tlc = st[0][0][0].name
            if tlc:
                if len(str(tlc)) >= 1 and len(str(tlc)) <= 5:
                    self.container.inputData.TLC.set(str(tlc))
            self.ToggleShowContainsMetal(fromUpdateTLC=True)
        except:
            pass

    def ToggleShowContainsMetal(self, fromUpdateTLC=False):
        if self.container.controlParameters.TOGGLE_METAL and not fromUpdateTLC:
            return True
        if not self.container.controlParameters.TOGGLE_METAL and not fromUpdateTLC:
            return False
        if self.container.inputData.MOLSMILESORSKETCH != 'DICT' and \
                self.container.inputData.MOLSMILESORSKETCH != 'PDBMMCIF':
            return False
        if not self.container.inputData.DICTIN2.isSet() and \
                not self.container.inputData.PDBMMCIFIN.isSet():
            return False
        if not os.path.isfile(str(self.container.inputData.DICTIN2.fullPath)) and \
                not os.path.isfile(str(self.container.inputData.PDBMMCIFIN.fullPath)):
            return False
        try:
            if self.container.inputData.MOLSMILESORSKETCH == 'DICT' and self.container.inputData.DICTIN2.isSet():
                if os.path.isfile(str(self.container.inputData.DICTIN2.fullPath)):
                    blocks = gemmi.cif.read(str(self.container.inputData.DICTIN2.fullPath))
                    for block in blocks:
                        for element in block.find_loop("_chem_comp_atom.type_symbol"):
                            if gemmi.Element(element).is_metal:
                                self.container.controlParameters.TOGGLE_METAL.set(True)
                                return True
            elif self.container.inputData.MOLSMILESORSKETCH == 'PDBMMCIF' and self.container.inputData.PDBMMCIFIN.isSet():
                st = gemmi.read_structure(str(self.container.inputData.PDBMMCIFIN.fullPath))
                lookup = {x.atom: x for x in st[0].all()}
                for atom in lookup.keys():
                    if atom.element.is_metal:
                        self.container.controlParameters.TOGGLE_METAL.set(True)
                        return True
            else:
                return False
        except:
            return False

    def useCoord(self):
        if self.container.controlParameters.USE_COORD:
            self.container.controlParameters.TOGGLE_NRANDOM.set(False)
            self.getWidget('TOGGLE_NRANDOM').setEnabled(False)
            self.getWidget('NRANDOM').setEnabled(False)
        else:
            self.getWidget('TOGGLE_NRANDOM').setEnabled(True)
            self.getWidget('NRANDOM').setEnabled(True)
