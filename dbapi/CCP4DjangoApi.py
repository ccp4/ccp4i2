
import sys
import os
import django
from pathlib import Path
from django.conf import settings
from django.utils.text import slugify
from django.db import IntegrityError
from lxml import etree
import json
import uuid
import time
import traceback
import requests
from core import CCP4Utils
from core import CCP4File
from core import CCP4Container
from core import CCP4TaskManager
from core import CCP4ErrorHandling
from dbapi import CCP4DbApi
from core import CCP4ProjectsManager
from core import CCP4Data
from core import CCP4ModelData
from core import CCP4PerformanceData
from xml.etree import ElementTree as ET

BASE_DIR = Path(__file__).resolve().parent
sys.path.append(BASE_DIR.__str__())

if sys.platform == "win32":
    HOME_CCP4I2_DIR_NAME = "CCP4I2"
else:
    HOME_CCP4I2_DIR_NAME = ".CCP4I2"

settings.configure(
    INSTALLED_APPS=(
        'CCP4i2',
    ),
    DATABASES={
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            # FIXME...not all database files are stored here
            'NAME': Path(CCP4Utils.getHOME()) / HOME_CCP4I2_DIR_NAME / 'db' / 'database.sqlite',
            'CONN_MAX_AGE': 0
        }
    },
)
# django.setup() must be called before `from CCP4i2 import models`
django.setup()
from CCP4i2 import models

class FakeDb(object):
    class FakeSignal:
        def emit(self, *arg, **kwarg):
            print(f'Ive been asked to emit {arg}, {kwarg}')

    def __init__(self):
        self.projectReset = FakeDb.FakeSignal()
        super().__init__()

    def __getattribute__(self, __name):
        print(f'Fakedb being interrogated for {__name}')
        return super().__getattribute__(__name)

    def getFileByJobContext(self, contextJobId=None, fileType=None, subType=None, contentFlag=None, projectId=None):

        assert contextJobId is not None
        assert fileType is not None

        contextJobIn = models.Jobs.objects.get(jobid=contextJobId)
        projectJobs = models.Jobs.objects.filter(
            parentjobid__isnull=True, projectid=contextJobIn.projectid)
        searchJobsList = [projectJob for projectJob in projectJobs if int(
            projectJob.jobnumber) <= int(contextJobIn.jobnumber)]
        searchJobsList.reverse()

        while len(searchJobsList) > 0:
            contextJob = searchJobsList.pop()
            print(f'Looking for context in {contextJob.jobnumber}')
            # First considering output/import files of job
            filterDict = {'filetypeid__filetypename': fileType}
            if isinstance(subType, list) and not 0 in subType and subType is not None:
                filterDict['filesubtype__in'] = subType
            elif not isinstance(subType, list) and subType != 0 and subType is not None:
                filterDict['filesubtype'] = subType
            if contentFlag is not None and contentFlag is not NotImplemented:
                if not isinstance(contentFlag, list):
                    filterDict['filecontent'] = contentFlag
                else:
                    filterDict['filecontent__in'] = contentFlag
            if projectId is not None:
                filterDict['jobid__projectid__projectid'] = projectId
            print(f'Using filterDict {filterDict}')
            fileQS = models.Files.objects.filter(**filterDict)

            # See if there is an item generated by import / output from the context Job
            jobFileQS = fileQS.filter(jobid=contextJob)
            if len(list(jobFileQS)) > 0:
                jobFileIdList = [jobFile.fileid for jobFile in jobFileQS]

                # Separate output files and import files
                importFileIds = [importFile.fileid.fileid for importFile in models.Importfiles.objects.filter(
                    fileid__fileid__in=jobFileIdList)]
                outputFileIds = [
                    jobFileId for jobFileId in jobFileIdList if jobFileId not in importFileIds]

                if len(outputFileIds) > 0:
                    if contextJob.taskname == 'coot_rebuild':
                        return outputFileIds.reverse()
                    else:
                        return outputFileIds
                elif len(importFileIds) > 0:
                    return importFileIds

            filterDict = {'fileid__filetypeid__filetypename': fileType}
            if isinstance(subType, list) and not 0 in subType and subType is not None:
                filterDict['fileid__filesubtype__in'] = subType
            elif not isinstance(subType, list) and subType != 0 and subType is not None:
                filterDict['fileid__filesubtype'] = subType
            if contentFlag is not None and contentFlag is not NotImplemented:
                if not isinstance(contentFlag, list):
                    filterDict['fileid__filecontent'] = contentFlag
                else:
                    filterDict['fileid__filecontent__in'] = contentFlag
            if projectId is not None:
                filterDict['jobid__projectid__projectid'] = projectId

            fileuseQS = models.Fileuses.objects.filter(**filterDict)
            jobFileuseQS = fileuseQS.filter(jobid=contextJob)
            if len(list(jobFileuseQS)) > 0:
                outputFileQS = jobFileuseQS.filter(roleid__roletext='in')
                if len(list(outputFileQS)) > 0:
                    outputIdList = [
                        outputFile.fileid.fileid for outputFile in outputFileQS]
                    if contextJob.taskname == 'coot_rebuild':
                        return outputIdList.reverse()
                    else:
                        return outputIdList
                inputFileQS = jobFileuseQS.filter(roleid__roletext="out")
                if len(list(inputFileQS)) > 0:
                    inputIdList = [
                        inputFile.fileid.fileid for inputFile in inputFileQS]
                    return inputIdList

        return []

    '''
    def getattr(self, attrName):
        logging.info(f'Asked FakeProjectsManager for attr {atttrName}')
        return super().getattr(attrName)
    '''

    def getTaskNameLookup(self, projectId=None, jobId=None, extras=False):
        # Fixme....this should produce a lookup of subtasks sfor use in CCP4i2 purgeJob
        try:
            print(f'In getTaskNameLookup {projectId}, {jobId}, {extras}')
        except Exception as err:
            print(f'Err in getTaskNameLookup {err}')
            traceback.print_stack()
        return {}

    def getProjectInfo(self, projectId=None, projectName=None, mode='all', checkPermission=True):
        try:
            if projectId is None:
                theQS = models.Projects.objects.filter(projectname=projectName)
            else:
                theQS = models.Projects.objects.filter(projectid=projectId)

            if isinstance(mode, list):
                arg = [item.lower() for item in mode]
            elif mode.lower() == 'all':
                arg = []
            else:
                arg = [mode.lower()]

            unPatchedValues = theQS.values(*arg)
            values = []
            for unPatchedValue in unPatchedValues:
                value = {}
                for key in unPatchedValue:
                    if key.endswith('_id'):
                        value[key[:-3]] = unPatchedValue[key]
                    else:
                        value[key] = unPatchedValue[key]
                values.append(value)
            result = list(values)[0]
            if len(arg) == 1:
                return result[arg[0]]
            return result
        except Exception as err:
            print(f'Err in getProjectInfo {err}')
            traceback.print_stack()
        return None

    def deleteFilesOnJobNumberAndParamName(self, projectId=None, jobNumberParamList=[]):
        try:
            for jobNumberParam in jobNumberParamList:
                # print('Requested to delete', jobNumberParam)
                try:
                    file = models.Files.objects.get(
                        jobid__projectid=projectId, jobid__jobnumber=jobNumberParam[0], jobparamname=jobNumberParam[1])
                    file.delete()
                except models.Files.DoesNotExist as err:
                    print(
                        f'Err in deleteFilesOnJobNumberAndParamName {err} {jobNumberParam}')
        except Exception as err:
            print(f'Err in deleteFilesOnJobNumberAndParamName {err}')
            traceback.print_stack()
        return None

    def getFileInfo(self, fileId=None, mode='all', returnType=None):
        assert fileId is not None
        theFileQS = models.Files.objects.filter(fileid=fileId)

        if isinstance(mode, list):
            arg = [item.lower() for item in mode]
        elif mode.lower() == 'all':
            arg = []
        else:
            arg = [mode.lower()]

        # Will need corrected for some cases
        replacements = {}

        def patch(label):
            return replacements.get(label, label)
        arg = list(map(patch, arg))

        unPatchedValues = theFileQS.values(*arg)
        listOfDicts = []
        for unPatchedValue in unPatchedValues:
            # outer loop over jobs matching jobId
            value = {}
            for key in unPatchedValue:
                # inner loop over parameters
                if key.endswith('_id'):
                    value[key[:-3]] = unPatchedValue[key]
                else:
                    value[key] = unPatchedValue[key]
            listOfDicts.append(value)
        result = listOfDicts[0]

        if len(arg) == 1 and returnType != dict:
            return result[arg[0]]
        elif returnType == list:
            return [item[1] for item in result.items()]
        return result

    def getJobInfo(self, jobId=None, mode='all', projectName=None, jobNumber=None, returnType=None):
        try:
            # print(f'jobId is {jobId}')
            if jobId is None:
                theJobQS = models.Jobs.objects.filter(
                    projectid__projectname=projectName, jobnumber=jobNumber)
            else:
                theJobQS = models.Jobs.objects.filter(jobid=jobId)
            assert len(list(theJobQS)) == 1

            if isinstance(mode, list):
                arg = [item.lower() for item in mode]
            elif mode.lower() == 'all':
                arg = []
            else:
                arg = [mode.lower()]

            replacements = {'projectname': 'projectid__projectname',
                            'projectid': 'projectid__projectid'}

            def patch(label):
                return replacements.get(label, label)
            arg = list(map(patch, arg))

            unPatchedValues = theJobQS.values(*arg)
            listOfDicts = []
            for unPatchedValue in unPatchedValues:
                # outer loop over jobs matching jobId
                value = {}
                for key in unPatchedValue:
                    # inner loop over parameters
                    if key == 'projectid__projectname':
                        value['projectname'] = unPatchedValue[key]
                    elif key == 'projectid__projectid':
                        value['projectid'] = unPatchedValue[key]
                    elif key.endswith('_id'):
                        value[key[:-3]] = unPatchedValue[key]
                    else:
                        value[key] = unPatchedValue[key]
                listOfDicts.append(value)
            result = listOfDicts[0]
            result['fileroot'] = list(theJobQS)[0].jobDirectory

            if len(arg) == 1 and returnType != dict:
                return result[arg[0]]
            elif returnType == list:
                return [item[1] for item in result.items()]

            jobFiles = models.Files.objects.filter(jobid=list(theJobQS)[0])
            result['filenames'] = {}
            for jobFile in jobFiles:
                result['filenames'][jobFile.jobparamname] = jobFile.filePath
            print(f'Response from getJobInfo is {result}')
            traceback.print_stack()
            return result
        except Exception as err:
            print(f'Err in getJobInfo {err} {mode} {returnType}')
            traceback.print_stack()
        return None

    def gleanJobFiles(self, jobId=None, container=None, dbOutputData=None, roleList=[CCP4DbApi.FILE_ROLE_OUT, CCP4DbApi.FILE_ROLE_IN], unSetMissingFiles=True):
        try:
            theJob = models.Jobs.objects.get(jobid=jobId)
            for role in roleList:
                roleid = models.Fileroles.objects.get(roleid=role)
                inputOutputFiles = self.findInputOutputs(container, role, [])
                for inputOutputFile in inputOutputFiles:

                    if isinstance(inputOutputFile, CCP4PerformanceData.CPerformanceIndicator):
                        try:
                            objList, xmlText, keyValues = inputOutputFile.saveToDb()
                            jobParamName = inputOutputFile.objectName()
                        except:
                            print(
                                f'ERROR in gleanJobFiles for {inputOutputFile.objectName()}')
                            objList, xmlText, keyValues = [], None, {}
                            jobParamName = ''
                        for key, value in keyValues.items():
                            keyType = models.Keytypes.objects.get(
                                keytypename=key)
                            if isinstance(value, str):
                                newKeyvalue = models.Jobkeycharvalues(
                                    jobid=theJob, keytypeid=keyType, value=value)
                                newKeyvalue.save()
                            else:
                                keyType = models.Keytypes.objects.get(
                                    keytypename=key)
                                newKeyvalue = models.Jobkeyvalues(
                                    jobid=theJob, keytypeid=keyType, value=value)
                                newKeyvalue.save()

                    elif isinstance(inputOutputFile, CCP4File.CDataFile):
                        print('Gleaning {} - {}'.format(inputOutputFile.objectName(),
                              inputOutputFile.getFullPath()))
                        jobParamName = inputOutputFile.objectName()
                        if len(inputOutputFile.getFullPath()) > 0:
                            try:
                                if inputOutputFile.dbFileId is not None and len(str(inputOutputFile.dbFileId)) != 0:
                                    theFile = models.Files.objects.get(
                                        fileid=str(inputOutputFile.dbFileId))
                                    # If the file was imported, there may already be a fileUse record for it: if not, create one
                                    try:
                                        existingFileUse = models.Fileuses.objects.get(
                                            fileid=theFile, jobid=theJob, roleid=roleid)
                                    except models.Fileuses.DoesNotExist:
                                        newFileUse = models.Fileuses(
                                            fileid=theFile, jobid=theJob, roleid=roleid, jobparamname=jobParamName)
                                        newFileUse.save()
                            except models.Fileuses.DoesNotExist as err:
                                print(
                                    'ObjectDoesNotExist issue gleaning {} - file not found'.format(jobParamName))
                                continue
                            except IntegrityError as err:
                                print(
                                    f'IntegrityError Issue gleaning {jobParamName} {inputOutputFile.dbFileId} {roleid.roleid} {theFile.filename}')
                                continue

                            if role == CCP4DbApi.FILE_ROLE_OUT:
                                if inputOutputFile.exists():
                                    fileTypeName = inputOutputFile.qualifiers(
                                        'mimeTypeName')
                                    if len(fileTypeName) == 0:
                                        print(
                                            f"Class {str(inputOutputFile.__class__)} Does not have an associated mimeTypeName....ASK FOR DEVELOPER FIX")
                                        if isinstance(inputOutputFile, CCP4File.CXmlDataFile):
                                            fileTypeName = 'application/xml'
                                    try:
                                        fileTypeId = models.Filetypes.objects.get(
                                            filetypename=fileTypeName)

                                        if inputOutputFile.subType != None:
                                            subType = int(
                                                inputOutputFile.subType)
                                        else:
                                            subType = None

                                        if inputOutputFile.contentFlag != None:
                                            fileContent = int(
                                                inputOutputFile.contentFlag)
                                        else:
                                            fileContent = None
                                        # print('Ready to save', fileContent,
                                        #      subType, fileTypeId.filetypeid, jobParamName)
                                        newFile = models.Files(
                                            filename=str(
                                                inputOutputFile.baseName),
                                            annotation=str(
                                                inputOutputFile.annotation),
                                            filetypeid=fileTypeId,
                                            filesubtype=subType,
                                            filecontent=fileContent,
                                            jobid=theJob,
                                            jobparamname=jobParamName,
                                            pathflag=1,
                                        )
                                        newFile.save()
                                        newFileUse = models.Fileuses(
                                            fileid=newFile, jobid=theJob, roleid=roleid, jobparamname=jobParamName)
                                        newFileUse.save()
                                    except Exception as err:
                                        print(
                                            f'Issue saving new file {jobParamName} - filetype ]{fileTypeName}] not recognised')

            return 0
        except Exception as err:
            print(f'Err in gleanFiles {err}')
            traceback.print_stack()
        return None

    def findInputOutputs(self, ofContainer, role, inputOutputsFound=[]):
        if isinstance(ofContainer, str):
            print(f'Cant findInputOutputs of string {ofContainer}')
            return inputOutputsFound
        else:
            for child in ofContainer.children():
                if isinstance(child, CCP4PerformanceData.CPerformanceIndicator):
                    inputOutputsFound.append(child)
                elif isinstance(child, CCP4Container.CContainer):
                    if role == CCP4DbApi.FILE_ROLE_IN and child.objectName() != 'outputData':
                        self.findInputOutputs(
                            child, role, inputOutputsFound=inputOutputsFound)
                    elif role == CCP4DbApi.FILE_ROLE_OUT and child.objectName() == 'outputData':
                        self.findInputOutputs(
                            child, role, inputOutputsFound=inputOutputsFound)
                elif isinstance(child, CCP4Data.CList):
                    for item in child:
                        if isinstance(item, CCP4File.CDataFile):
                            if len(item.objectName()) == 0:
                                item.setObjectName(child.objectName())
                            inputOutputsFound.append(item)
                        elif isinstance(item, CCP4Container.CContainer):
                            self.findInputOutputs(
                                item, role, inputOutputsFound=inputOutputsFound)
                elif isinstance(child, CCP4File.CDataFile):
                    inputOutputsFound.append(child)
            return inputOutputsFound


class FakeProjectsManager(object):

    def __init__(self):
        print('FakePM Init in')
        self._db = FakeDb()
        print('FakePM Init out')
        super().__init__()

    def db(self):
        return self._db

    def __getattribute__(self, __name):
        print(f'FakeProjectsManager being interrogated for {__name}')
        return super().__getattribute__(__name)

    def setOutputFileNames(self, container=None, projectId=None, jobNumber=None, force=True):
        myErrorReport = CCP4ErrorHandling.CErrorReport()
        relPath = os.path.sep.join(
            ['CCP4_JOBS']+[f'job_{numberElement}' for numberElement in jobNumber.split('.')])
        theJob = models.Jobs.objects.get(
            projectid__projectid=projectId, jobnumber=jobNumber)
        jobName = f'{jobNumber}_{slugify(theJob.projectid.projectname)}_{theJob.taskname}_'
        dataList = container.outputData.dataOrder()
        for objectName in dataList:
            try:
                dobj = container.outputData.find(objectName)
                # print 'setOutputData get',objectName,dobj.get(),dobj.isSet()
                if isinstance(dobj, CCP4File.CDataFile) and (force or not dobj.isSet()):
                    dobj.setOutputPath(
                        jobName=jobName, projectId=projectId, relPath=relPath)
                if isinstance(dobj, CCP4ModelData.CPdbDataFile):
                    oldBaseName, oldExt = os.path.splitext(str(dobj.baseName))
                    if dobj.contentFlag is None or int(dobj.contentFlag) == 1:
                        dobj.baseName.set(f'{oldBaseName}.pdb')
                    if int(dobj.contentFlag) == 2:
                        dobj.baseName.set(f'{oldBaseName}.cif')

            except Exception as err:
                print(
                    f'Exception in setOutputFileNames for {dobj.objectPath()} {str(err)}')
        return myErrorReport

    def interpretDirectory(self, path):
        absPath = os.path.abspath(path)
        theProject = None
        for project in models.Projects.objects.all():
            # print(project.projectname, '{}/'.format(project.projectdirectory))
            if absPath.startswith('{}/'.format(project.projectdirectory)):
                theProject = project
                break
        if theProject is not None:
            # projectName, relPath, projectId
            return theProject.projectname, absPath[len(theProject.projectdirectory)+1:], theProject.projectid
        else:
            return [None, None, None]

    def getProjectDirectory(self, projectName=None, testAlias=True, projectId=None):
        # print('*****In FakeGetProjectDirectory {}, {}, {}'.format(projectName, testAlias, projectId))
        if projectId is not None:
            # Baffling edge case
            if testAlias and projectId == 'CCP4I2_TOP':
                return os.environ['CCP4I2_TOP']
            try:
                theProject = models.Projects.objects.get(projectid=projectId)
            except models.Projects.DoesNotExist as err:
                print(
                    f'In getProjectDirectory for non existent projectId {projectId}')
                return None
        else:
            try:
                theProject = models.Projects.objects.get(
                    projectname=projectName)
            except models.Projects.DoesNotExist as err:
                print(
                    f'In getProjectDirectory for non existent projectName {projectName}')
                return None
        return theProject.projectdirectory

    def jobDirectory(self, jobId=None, projectName=None, jobNumber=None):
        assert jobId is not None or (
            projectName is not None and jobNumber is not None)
        # print('in FPM', jobId, projectName, jobNumber)
        if jobId is not None:
            return models.Jobs.objects.get(jobid=jobId).jobDirectory
        else:
            return models.Jobs.objects.get(projectid__projectname=projectName, jobnumber=jobNumber).jobDirectory

    def makeFileName(self, jobId=None, mode='PROGRAMXML'):
        theJob = models.Jobs.objects.get(jobid=jobId)
        defNames = {'ROOT': '', 'PARAMS': 'params.xml', 'JOB_INPUT': 'input_params.xml', 'PROGRAMXML': 'program.xml',
                    'LOG': 'log.txt', 'STDOUT': 'stdout.txt', 'STDERR': 'stderr.txt',
                    'INTERRUPT': 'interrupt_status.xml', 'DIAGNOSTIC': 'diagnostic.xml', 'REPORT': 'report.html',
                    'DIAGNOSTIC_REPORT': 'diagnostic_report.html', 'TABLE_RTF': 'tables.rtf',
                    'TABLES_DIR': 'tables_as_csv_files', 'XML_TABLES_DIR': 'tables_as_xml_files',
                    'LOG': 'log.txt', 'COM': 'com.txt', 'MGPICDEF': 'report.mgpic.py', 'PIC': 'report.png', 'RVAPIXML': 'i2.xml'}
        jobPath = Path(theJob.jobDirectory) / defNames[mode]
        return str(jobPath)

# Decoorator to install and use FakeProjectManager


def UsingFakePM(func):
    def wrapper(*args, **kwargs):
        print("Something is happening before the function is called.")
        oldPM = CCP4ProjectsManager.CProjectsManager.insts
        try:
            CCP4ProjectsManager.CProjectsManager.insts = FakeProjectsManager()
            result = func(*args, **kwargs)
        except Exception as err:
            print('Encountered issue while in FakePM decorator')
            traceback.print_exc()
        finally:
            CCP4ProjectsManager.CProjectsManager.insts = oldPM
            print("Something is happening after the function is called.")
        return result
    return wrapper


def modelValues(objectType="", predicate={}, order_byArray=[], valuesArray=[]):
    try:
        ModelClass = getattr(models, objectType)
        querySet = ModelClass.objects.all()
        if len(predicate.items()) > 0:
            for key in predicate:
                if key.endswith('isnull'):
                    print (key, predicate[key])
                    if 'true' in predicate[key].lower():
                        predicate[key] = True
                    elif 'false' in predicate[key].lower():
                        predicate[key] = False
                print (predicate)
            querySet = querySet.filter(**predicate)
        if len(order_byArray) > 0:
            querySet = querySet.order_by(*order_byArray)
        # print(model, filterDict, valuesArray, order_byArray)
        valuesQuerySet = querySet.values(*valuesArray)
        status = 'Success'
        exception = ""
    except Exception as err:
        exception = str(err)
        valuesQuerySet = []
        status = 'Failure'
    return {'results': list(valuesQuerySet), 'status': status, 'Exception': exception}


def makeTerminateFile(queryDict):
    theJob = models.Jobs.objects.get(jobid=queryDict['jobId'])
    terminateFilePath = os.path.join(theJob.jobDirectory, "TERMINATE")
    with open(terminateFilePath, "w") as terminateFile:
        terminateFile.write("TERMINATE")
    return json.dumps({"status": "Success"}), "application/json"


def getJobFile(jobId=None, projectId=None, projectName=None, jobNumber=None, fileName=None):
    if jobId is not None:
        theJob = models.Jobs.objects.get(jobid=jobId)
    elif jobNumber is None or (projectId is None or projectName is None):
        raise Exception(
            "need jobId or (jobNumber and (projectId or projectName))")
    elif projectId is None:
        theJob = models.Jobs.objects.get(
            projectname=projectName, jobnumber=jobNumber)
    else:
        theJob = models.Jobs.objects.get(
            projectname=projectName, jobnumber=jobNumber)

    filePath = os.path.join(theJob.jobDirectory, fileName)
    with open(filePath, "r") as f:
        d = f.read()
    return d


def getFileWithPredicate(predicate):
    theFile = models.Files.objects.get(**predicate)
    filePath = theFile.filePath
    with open(filePath, "rb") as f:
        d = f.read()
    return d, filePath, theFile.filetypeid.filetypename


def getProjectFileData(projectId, relPath, baseName):
    from urllib.parse import unquote
    relPath = unquote(relPath)
    filePath = os.path.join(models.Projects.objects.get(
        projectid=projectId).projectdirectory, relPath, baseName)
    with open(filePath, "rb") as f:
        d = f.read()
    return d, filePath


def jobForPredicate(jobId=None, projectId=None, projectName=None, jobNumber=None):
    print(jobId, projectId, projectName, jobNumber)
    if jobId is None:
        if projectId is not None:
            jobs = models.Jobs.objects.filter(projectid__projectid=projectId)
        else:
            jobs = models.Jobs.objects.filter(
                projectid__projectname=projectName)
        theJob = jobs.get(jobnumber=str(jobNumber))
    else:
        theJob = models.Jobs.objects.get(jobid=jobId)
    return theJob


@UsingFakePM
def uploadFileToJob(fileRoot="output", jobId=None, fileExtension=".txt", file=b''):
    theJob = models.Jobs.objects.get(jobid=jobId)
    baseName = f"{fileRoot}{fileExtension}"
    filePath = os.path.join(theJob.jobDirectory, baseName)
    iFile = 0
    while os.path.exists(filePath):
        baseName = f"{fileRoot}_{iFile}{fileExtension}"
        filePath = os.path.join(theJob.jobDirectory, baseName)
        iFile += 1
    with open(filePath, "wb") as outputFile:
        outputFile.write(file)
    relPath = os.path.join(
        "CCP4_JOBS", "/".join([f"job_{jN}" for jN in theJob.jobnumber.split(".")]))
    return {"project": theJob.projectid.projectid, "relPath": relPath, "baseName": baseName}


@UsingFakePM
def uploadFileForJobObject(jobId=None, projectId=None, projectName=None, jobNumber=None,
                           objectPath=None, fileName=None, file=b''):
    if jobId is None and ((projectId is None and projectName is None) or jobNumber is None):
        raise Exception('Unable to infer job in uploadFileForJobObject')
    if fileName is None:
        raise Exception('No fileName given for uploadFileForJobObject')
    theJob = jobForPredicate(
        jobId=jobId, projectId=projectId, projectName=projectName, jobNumber=jobNumber)

    fileRoot, fileExtension = os.path.splitext(fileName)
    uploadResult = uploadFileToJob(fileRoot, theJob.jobid, fileExtension, file)
    valueXMLText = f'''<{objectPath.split('.')[-1]}>
        <project>{uploadResult['project']}</project>
        <relPath>{uploadResult['relPath']}</relPath>
        <baseName>{uploadResult['baseName']}</baseName>
        <annotation>Imported from upload of {fileName}</annotation>
    </{objectPath.split('.')[-1]}>'''
    setJobParameterByXML(jobId, objectPath, valueXMLText)
    theJobPlugin = getJobPlugin(theJob)
    objectElement = theJobPlugin.container.locateElement(objectPath)
    # Here validate the file by attempting to load it and apply setContentFlag
    objectElement.loadFile()
    objectElement.setContentFlag()
    saveParamsForJob(theJobPlugin=theJobPlugin, theJob=theJob)
    return ET.tostring(objectElement.getEtree()).decode('utf-8')


def getProjectDirectory(projectId=None, projectName=None, jobId=None):
    if projectId is not None:
        return models.Projects.objects.get(projectid=projectId).projectdirectory
    elif projectName is not None:
        return models.Projects.objects.get(projectname=projectName).projectdirectory
    elif jobId is not None:
        return models.Jobs.objects.get(jobid=jobId).projectid.projectdirectory
    return None


def getProjectJobFileName(projectId=None, fileName=None, jobNumber="1", subJobNumber=""):
    # MN: This is mostly deeply flawed logic, and not at all how job numbers should work ! Copied from CDbApi and rescued for
    # "." in jobNumber
    if subJobNumber != "":
        fname = os.path.join(getProjectDirectory(
            projectId=projectId), "CCP4_JOBS", "job_"+jobNumber, "job_"+subJobNumber, fileName)
    else:
        if "." in jobNumber:
            jobNumberPathElements = [
                f"job_{number}" for number in jobNumber.split(".")]
            fname = os.path.join(getProjectDirectory(
                projectId=projectId), "CCP4_JOBS", *jobNumberPathElements, fileName)
        else:
            fname = os.path.join(getProjectDirectory(
                projectId=projectId), "CCP4_JOBS", "job_"+jobNumber, fileName)
    return fname


@UsingFakePM
def getProjectJobFile(projectId=None, projectName=None, fileName=None, jobNumber="1", subJobNumber=""):
    if projectId is None:
        if projectName is not None:
            projectId = models.Projects.objects.get(projectname=projectName).projectid
    fname = getProjectJobFileName(
        projectId, fileName, jobNumber, subJobNumber)
    d = fname
    if fname.endswith(".png"):
        with open(fname, "rb") as f:
            d = f.read()
    else:
        with open(fname,"rb") as f:
            d = f.read()
    return d


@UsingFakePM
def removeDefaults(container):
    for child in container.children():
        if hasattr(child, 'objectName') and child.objectName() not in ['inputData', 'outputData']:
            if isinstance(child, CCP4Container.CContainer):
                if child.objectName() != 'outputData':
                    removeDefaults(child)
            else:
                if not child.isSet(allowDefault=False, allSet=False):
                    if container.objectName() != "temporary":
                        try:
                            container.deleteObject(child.objectName())
                        except Exception as err:
                            print(
                                f'Issue deleting {child.objectName()} from {container.objectName()}')


@UsingFakePM
def cloneJob(jobId=None):
    oldJob = models.Jobs.objects.get(jobid=jobId)
    theProject = oldJob.projectid

    taskName = oldJob.taskname

    try:
        lastJobNumber = max([int(job.jobnumber) for job in
                             models.Jobs.objects.filter(projectid=theProject).filter(parentjobid__isnull=True)])
    except ValueError:
        lastJobNumber = 0

    nextJobNumber = str(lastJobNumber + 1)

    try:
        preceedingJobId = models.Jobs.objects.get(
            projectid=theProject, jobnumber=str(lastJobNumber))
    except models.Jobs.DoesNotExist as err:
        preceedingJobId = None

    newJobDir = Path(theProject.projectdirectory) / \
        "CCP4_JOBS" / "job_{}".format(nextJobNumber)
    newJobId = uuid.uuid1().hex
    print(f"newJobDir {newJobDir}, newJobId {newJobId}")
    from core import CCP4TaskManager
    taskManager = CCP4TaskManager.CTaskManager()
    pluginClass = taskManager.getPluginScriptClass(taskName)
    newJobDir.mkdir(exist_ok=True, parents=True)
    theJobPlugin = pluginClass(workDirectory=str(newJobDir))
    print(f"theJobPlugin {theJobPlugin}")

    # Load cloned parameters
    theJobPlugin.container.loadDataFromXml(
        str(Path(oldJob.jobDirectory) / "input_params.xml"))

    try:
        dataList = theJobPlugin.container.outputData.dataOrder()
        for objectName in dataList:
            dobj = theJobPlugin.container.outputData.find(objectName)
            if isinstance(dobj, CCP4File.CDataFile):
                dobj.unSet()
    except Exception as err:
        raise (err)

    newJob = models.Jobs(jobid=newJobId,
                         jobnumber=str(nextJobNumber),
                         finishtime=0.,
                         status=models.Jobstatus.objects.get(
                             statustext="Pending"),
                         evaluation=None,
                         useragent=models.Useragents.objects.all()[0],
                         jobtitle=taskManager.getTitle(taskName),
                         projectid=theProject,
                         taskname=taskName,
                         taskversion=None,
                         parentjobid=None,
                         preceedingjobid=preceedingJobId,
                         treeleft=None,
                         treeright=None,
                         userid=theProject.userid)

    removeDefaults(theJobPlugin.container)
    saveParamsForJob(theJobPlugin, newJob)

    newJob.save()

    theProject.lastaccess = time.time()
    theProject.lastjobnumber = newJob.jobnumber
    theProject.save()

    return newJob.jobid, newJob.jobnumber, theProject.projectid, None


@UsingFakePM
def updateJobStatus(jobId=None, statusId=None):
    theJob = models.Jobs.objects.get(jobid=jobId)
    theStatus = models.Jobstatus.objects.get(statusid=statusId)
    theJob.status = theStatus
    theJob.save()
    return theJob.jobid, theJob.projectid.projectid, theStatus.statustext


@UsingFakePM
def createJob(projectId=None, projectName=None, parentJobId=None, taskName=None, jobNumber=None, jobId=None, saveParams=True):
    print(projectName, projectId)
    if parentJobId is not None and projectId is None:
        parentJob = models.Jobs.objects.get(jobid=parentJobId)
        theProject = parentJob.projectid
    elif projectId is None and projectName is not None:
        parentJob = None
        theProject = models.Projects.objects.get(projectname=projectName)
        projectId = theProject.projectid
    else:
        parentJob = None
        theProject = models.Projects.objects.get(projectid=projectId)

    if jobNumber is None:
        projectJobs = models.Jobs.objects.filter(
            projectid__projectid=projectId).filter(parentjobid__isnull=True)
        if len(projectJobs) == 0:
            lastJobNumber = 0
        else:
            lastJobNumber = sorted([int(a.jobnumber) for a in projectJobs])[-1]
        lastJobNumber = str(lastJobNumber)
    else:
        jobNumberElements = jobNumber.split('.')
        jobNumberElements[-1] = str(int(jobNumberElements[-1])-1)
        lastJobNumber = ".".join(jobNumberElements)

    jobNumberElements = lastJobNumber.split('.')
    jobNumberElements[-1] = str(int(jobNumberElements[-1])+1)
    nextJobNumber = ".".join(jobNumberElements)

    preceedingJobId = None
    try:
        preceedingJobId = models.Jobs.objects.get(
            projectid__projectid=projectId, jobnumber=str(lastJobNumber))
    except models.Jobs.DoesNotExist as err:
        preceedingJobId = None

    pathElements = [theProject.projectdirectory, "CCP4_JOBS"] + \
        ["job_{}".format(jNo) for jNo in jobNumberElements]
    newJobString = os.path.join(*pathElements)
    newJobDir = Path(newJobString)

    if jobId is None:
        newJobId = uuid.uuid1().hex
    else:
        newJobId = jobId

    taskManager = CCP4TaskManager.CTaskManager()
    pluginClass = taskManager.getPluginScriptClass(taskName)
    if saveParams:
        newJobDir.mkdir(exist_ok=True, parents=True)
    theJobPlugin = pluginClass(workDirectory=str(newJobDir))

    argDict = dict(jobid=newJobId,
                   jobnumber=str(nextJobNumber),
                   creationtime=time.time(),
                   finishtime=0.,
                   status=models.Jobstatus.objects.get(
                       statustext="Pending"),
                   evaluation=None,
                   useragent=models.Useragents.objects.all()[0],
                   jobtitle=taskManager.getTitle(taskName),
                   projectid=theProject,
                   taskname=taskName,
                   taskversion=None,
                   parentjobid=parentJob,
                   preceedingjobid=preceedingJobId,
                   treeleft=None,
                   treeright=None,
                   userid=theProject.userid)
    print('argDict', argDict)
    newJob = models.Jobs(**argDict)

    if saveParams:
        removeDefaults(theJobPlugin.container)
        saveParamsForJob(theJobPlugin, newJob)
    newJob.save()

    return newJob.jobid, newJob.jobnumber, theProject.projectid, parentJobId


@UsingFakePM
def getJobPlugin(theJob, parent=None, dbHandler=None):
    taskManager = CCP4TaskManager.CTaskManager()

    pluginClass = taskManager.getPluginScriptClass(theJob.taskname)
    try:
        pluginInstance = pluginClass(
            workDirectory=theJob.jobDirectory, parent=parent, dbHandler=dbHandler)
    except Exception as err:
        traceback.print_exc()

    defFile = os.path.join(theJob.jobDirectory, 'params.xml')
    if not os.path.exists(defFile):
        # print('No params.xml at ', defFile)
        defFile1 = os.path.join(theJob.jobDirectory, 'input_params.xml')
        if not os.path.exists(defFile1):
            # print('No params.xml at ', defFile1)
            raise Exception('no defFile found')
        defFile = defFile1
    pluginInstance.container.loadDataFromXml(
        defFile, check=False, loadHeader=False)
    return pluginInstance


@UsingFakePM
def saveParamsForJob(theJobPlugin, theJob, mode='JOB_INPUT', excludeUnset=True):
    # print(f'into saveParams for {theJob.jobnumber} excludeUnset: {excludeUnset}')
    # sys.stdout.flush()
    fileName = theJobPlugin.makeFileName(mode)
    # print(f'saveParams in {fileName}')
    # sys.stdout.flush()
    if os.path.exists(fileName):
        backup = CCP4Utils.backupFile(fileName, delete=False)
    if theJobPlugin.container.header is None:
        theJobPlugin.container.addHeader()
    theJobPlugin.container.header.projectName.set(theJob.projectid.projectname)
    theJobPlugin.container.header.projectId.set(theJob.projectid.projectid)
    theJobPlugin.container.header.jobNumber.set(theJob.jobnumber)
    theJobPlugin.container.header.jobId.set(theJob.jobid)
    f = CCP4File.CI2XmlDataFile(fullPath=fileName)
    f.header.set(theJobPlugin.container.header)
    f.header.function.set('PARAMS')
    f.header.setCurrent()
    bodyEtree = theJobPlugin.container.getEtree(excludeUnset=excludeUnset)
    ET.indent(bodyEtree)
    f.saveFile(bodyEtree=bodyEtree)
    # print(f'out of saveParams for {theJob.jobnumber} excludeUnset: {excludeUnset}')
    # sys.stdout.flush()

    return


@UsingFakePM
def getJobContainer(theJob):
    defFile = CCP4TaskManager.CTaskManager().lookupDefFile(
        name=theJob.taskname, version=None)
    # print 'CProjectDirToDb.globJobs defFile',defFile
    container = CCP4Container.CContainer()
    container.loadContentsFromXml(defFile, guiAdmin=True)
    if os.path.exists(os.path.join(theJob.jobDirectory, "params.xml")):
        container.loadDataFromXml(os.path.join(
            theJob.jobDirectory, "params.xml"))
    else:
        container.loadDataFromXml(os.path.join(
            theJob.jobDirectory, "input_params.xml"))
    return container


@UsingFakePM
def setJobParameterByXML(jobId, objectPath, valueXMLText):
    newValueEtree = ET.fromstring(valueXMLText)
    theJob = models.Jobs.objects.get(jobid=jobId)
    theJobPlugin = getJobPlugin(theJob)
    objectElement = theJobPlugin.container.locateElement(objectPath)
    objectElement.unSet()
    objectElement.setEtree(newValueEtree)
    saveParamsForJob(theJobPlugin=theJobPlugin, theJob=theJob)
    return ET.tostring(objectElement.getEtree()).decode('utf-8')


@UsingFakePM
def getReportJobInfo(jobId=None):
    theJob = models.Jobs.objects.get(jobid=jobId)
    result = {
        'finishtime': theJob.finishtime,
        'status': theJob.status.statustext,
        'taskname': theJob.taskname,
        'taskversion': theJob.taskversion,
        'jobnumber': theJob.jobnumber,
        'projectid': theJob.projectid.projectid,
        'jobtitle': theJob.jobtitle,
        'creationtime': theJob.creationtime,
        'projectname': theJob.projectid.projectname,
        'fileroot': theJob.jobDirectory,
        'tasktitle': theJob.taskname,
        'jobid': theJob.jobid
    }

    inputFiles = []
    for fileUse in models.Fileuses.objects.filter(jobid=theJob):
        inputFile = {
            'filetypeid': fileUse.fileid.filetypeid.filetypeid,
            'filename': fileUse.fileid.filename,
            'annotation': fileUse.fileid.annotation,
            'jobparamname': fileUse.jobparamname,
            'jobid': fileUse.fileid.jobid.jobid,
            'pathflag': fileUse.fileid.pathflag,
            'filetype': fileUse.fileid.filetypeid.filetypename,
            'projectid': fileUse.fileid.jobid.projectid.projectid,
            'jobnumber': fileUse.fileid.jobid.jobnumber,
            'projectname': fileUse.fileid.jobid.projectid.projectname,
            'filetypeclass': CCP4DbApi.FILETYPES_CLASS[fileUse.fileid.filetypeid.filetypeid],
            'fileId': fileUse.fileid.fileid
        }
        if inputFile['pathflag'] == 1:
            inputFile['relpath'] = os.path.join(
                "CCP4_JOBS", fileUse.fileid.jobid.jobDirectory.split("CCP4_JOBS")[1])
        elif inputFile['pathflag'] == 2:
            inputFile['relpath'] = "CCP4_IMPORTED_FILES"
        inputFiles.append(inputFile)
    result['inputfiles'] = inputFiles

    outputFiles = []
    for theFile in models.Files.objects.filter(jobid=theJob):
        outputFile = {
            'filetypeid': theFile.filetypeid.filetypeid,
            'filename': theFile.filename,
            'annotation': theFile.annotation,
            'jobparamname': theFile.jobparamname,
            'jobid': theFile.jobid.jobid,
            'pathflag': theFile.pathflag,
            'filetype': theFile.filetypeid.filetypename,
            'projectid': theFile.jobid.projectid.projectid,
            'jobnumber': theFile.jobid.jobnumber,
            'projectname': theFile.jobid.projectid.projectname,
            'filetypeclass': CCP4DbApi.FILETYPES_CLASS[theFile.filetypeid.filetypeid],
            'fileId': theFile.fileid
        }
        outputFile['baseName'] = outputFile['filename']
        outputFile['relpath'] = os.path.join(
            "CCP4_JOBS", theFile.jobid.jobDirectory.split("CCP4_JOBS")[1])
        outputFile['relPath'] = os.path.join(
            "CCP4_JOBS", theFile.jobid.jobDirectory.split("CCP4_JOBS")[1])
        if outputFile['pathflag'] == 2:
            outputFile['relpath'] = "CCP4_IMPORTED_FILES"
            outputFile['relPath'] = "CCP4_IMPORTED_FILES"
        outputFiles.append(outputFile)

    result['outputfiles'] = outputFiles

    result['filenames'] = {}

    try:
        container = getJobContainer(models.Jobs.objects.get(jobid=jobId))
    except:
        pass
    else:
        # Get the data keyed by task parameter name- not necessarilly all files but should all have __str__ methods
        for key in container.inputData.dataOrder():
            if isinstance(container.inputData.find(key), CCP4Data.CList):
                result['filenames'][key] = []
                for item in container.inputData.find(key):
                    if os.path.exists(item.__str__()):
                        result['filenames'][key].append(item.__str__())
                    else:
                        result['filenames'][key].append("")
            else:
                try:
                    item = container.inputData.find(key).__str__()
                    if os.path.exists(item):
                        result['filenames'][key] = item
                    else:
                        result['filenames'][key] = ""
                except:
                    result['filenames'][key] = ""
        for key in container.outputData.dataOrder():
            if isinstance(container.outputData.find(key), CCP4Data.CList):
                result['filenames'][key] = []
                for item in container.outputData.find(key):
                    if os.path.exists(item.__str__()):
                        result['filenames'][key].append(item.__str__())
                    else:
                        result['filenames'][key].append("")
            else:
                try:
                    item = container.outputData.find(key).__str__()
                    if os.path.exists(item):
                        result['filenames'][key] = item
                    else:
                        result['filenames'][key] = ""
                except:
                    result['filenames'][key] = ""

    return result


@UsingFakePM
def simpleFailedReport(title1, title2=""):
    outer = ET.Element('CCP4i2Report', key="report_0")
    inner = ET.SubElement(
        outer, 'CCP4i2ReportTitle', title1=title1, title2=title2)
    return outer


@UsingFakePM
def getReportXML(jobId=None, projectId=None, jobNumber=None, projectName=None):
    theJob = jobForPredicate(
        jobId=jobId, projectId=projectId, projectName=projectName, jobNumber=jobNumber)

    from core import CCP4Modules
    # print(self, 'reportForTask_XML_Status', taskname, outputXml, status, jobId)
    reportClass = CCP4Modules.TASKMANAGER().getReportClass(name=theJob.taskname)
    sys.stdout.flush()
    if reportClass is None:
        print(f'Failed to find report class for task {theJob.taskname}')
        return simpleFailedReport('Failed to find report class for task', theJob.taskname)
    watchFile = CCP4Modules.TASKMANAGER().getReportAttribute(
        theJob.taskname, 'WATCHED_FILE')
    reportJobInfo = getReportJobInfo(theJob.jobid)
    parser = ET.XMLParser()

    from report import CCP4RvapiParser
    from report import CCP4ReportParser

    xmlPath = Path(theJob.jobDirectory) / 'program.xml'
    if not xmlPath.exists():
        xmlPath = Path(theJob.jobDirectory) / 'XMLOUT.xml'
        if not xmlPath.exists():
            xmlPath = Path(theJob.jobDirectory) / 'i2.xml'
            parser = CCP4RvapiParser.PARSER()
            if not xmlPath.exists():
                watchedPath = Path(
                    theJob.jobDirectory) / Path(watchFile)
                print(f'watchFile is {watchedPath}')
                if watchedPath.exists():
                    xmlPath = None
                else:
                    return simpleFailedReport('No programXML found', theJob.status.statustext)

    outputXml = None
    if xmlPath is not None:
        lookup = ET.ElementDefaultClassLookup(
            element=CCP4ReportParser.SearchableElement)
        parser.set_element_class_lookup(lookup)

        outputXml = ET.fromstring(
            bytes(open(xmlPath, "r").read(), "utf-8"), parser)

    status = theJob.status.statustext
    report = reportClass(xmlnode=outputXml,
                         jobInfo=reportJobInfo,
                         standardise=(status not in [
                                      'Running', 'Running remotely', 'Pending', 'Unknown', 'Queued']),
                         jobStatus=status, jobNumber=theJob.jobnumber)
    reportEtree = report.as_data_etree()
    return ET.tostring(reportEtree).decode('utf-8')
