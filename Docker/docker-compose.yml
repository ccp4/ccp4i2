# CCP4i2 Docker Compose - Local Development
#
# This compose file sets up the full CCP4i2 stack for local development:
# - Django REST API server
# - Next.js web client
# - PostgreSQL database (optional, defaults to SQLite)
# - Shell container for CCP4 setup/maintenance
#
# Prerequisites:
#   - CCP4 installed locally (path configured in .env)
#   - Docker and Docker Compose installed
#
# Usage:
#   # Copy example env file and configure
#   cp Docker/.env.example Docker/.env
#
#   # Start all services
#   docker compose -f Docker/docker-compose.yml up
#
#   # Start only server (for Electron client development)
#   docker compose -f Docker/docker-compose.yml up server
#
#   # Rebuild after code changes
#   docker compose -f Docker/docker-compose.yml up --build
#
#   # Start shell container for CCP4 setup (interactive)
#   docker compose -f Docker/docker-compose.yml run --rm shell
#
#   # Or start shell in background and attach later
#   docker compose -f Docker/docker-compose.yml up -d shell
#   docker compose -f Docker/docker-compose.yml exec shell bash

services:
  # Django REST API Server
  server:
    platform: linux/amd64
    build:
      context: ..
      dockerfile: Docker/server/Dockerfile
    ports:
      - "${SERVER_PORT:-8000}:8000"
    environment:
      - SECRET_KEY=${SECRET_KEY:-dev-secret-key-change-in-production}
      - DEBUG=${DEBUG:-true}
      # Use azure_extensions.settings which includes compounds apps
      - DJANGO_SETTINGS_MODULE=azure_extensions.settings
      - CCP4_DATA_PATH=/mnt/ccp4data
      - CCP4_VERSION=${CCP4_VERSION:-ccp4-9}
      - CCP4I2_PROJECTS_DIR=/mnt/projects
      - DATABASE_URL=${DATABASE_URL:-sqlite:////mnt/projects/ccp4i2.sqlite}
      - ALLOWED_HOSTS=${ALLOWED_HOSTS:-localhost,127.0.0.1}
      - CORS_ALLOWED_ORIGINS=${CORS_ALLOWED_ORIGINS:-http://localhost:3000}
      - USE_GUNICORN=${USE_GUNICORN:-false}
      # Azure AD Authentication (set CCP4I2_REQUIRE_AUTH=true in .env to enable)
      - CCP4I2_REQUIRE_AUTH=${CCP4I2_REQUIRE_AUTH:-false}
      - AZURE_AD_CLIENT_ID=${AZURE_AD_CLIENT_ID:-}
      - AZURE_AD_TENANT_ID=${AZURE_AD_TENANT_ID:-}
      # Bootstrap platform admins (comma-separated emails)
      - PLATFORM_ADMIN_EMAILS=${PLATFORM_ADMIN_EMAILS:-}
    volumes:
      # Mount CCP4 installation (read-only)
      - ${CCP4_PATH:-/opt/ccp4}:/mnt/ccp4data/${CCP4_VERSION:-ccp4-9}:ro
      # Mount projects directory (read-write, separate from ccp4data)
      - ${PROJECTS_PATH:-./data/projects}:/mnt/projects
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/api/ccp4i2/health/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: unless-stopped

  # Next.js Web Client
  client:
    build:
      context: ..
      dockerfile: Docker/client/Dockerfile
      args:
        # Azure AD Authentication (baked in at build time for Next.js)
        NEXT_PUBLIC_AAD_CLIENT_ID: ${NEXT_PUBLIC_AAD_CLIENT_ID:-}
        NEXT_PUBLIC_AAD_TENANT_ID: ${NEXT_PUBLIC_AAD_TENANT_ID:-}
        NEXT_PUBLIC_REQUIRE_AUTH: ${NEXT_PUBLIC_REQUIRE_AUTH:-false}
    ports:
      - "${CLIENT_PORT:-3000}:3000"
    environment:
      - NEXT_PUBLIC_API_URL=${API_URL:-http://localhost:8000}
      - NODE_ENV=${NODE_ENV:-development}
      # Server-side proxy URL (for container-to-container communication)
      - API_BASE_URL=http://server:8000
    depends_on:
      server:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    restart: unless-stopped

  # Shell container for CCP4 setup and maintenance
  # Provides an interactive environment matching the server container
  # with read-write access to the CCP4 data volume
  shell:
    platform: linux/amd64
    build:
      context: ..
      dockerfile: Docker/server/Dockerfile
    profiles:
      - shell  # Only starts with: docker compose --profile shell up
    stdin_open: true  # Keep stdin open for interactive use
    tty: true         # Allocate a pseudo-TTY
    environment:
      - CCP4_DATA_PATH=/mnt/ccp4data
      - CCP4I2_PROJECTS_DIR=/mnt/projects
      # Use azure_extensions.settings which includes compounds apps
      - DJANGO_SETTINGS_MODULE=azure_extensions.settings
      - SECRET_KEY=${SECRET_KEY:-dev-secret-key-change-in-production}
    volumes:
      # Mount CCP4 data directory (READ-WRITE for setup/building)
      - ${CCP4_DATA_PATH:-./data/ccp4data}:/mnt/ccp4data
      # Mount projects directory (separate from ccp4data to avoid permission issues)
      - ${PROJECTS_PATH:-./data/projects}:/mnt/projects
    entrypoint: ["/bin/bash"]
    command: ["-c", "echo 'CCP4i2 Shell Container Ready. CCP4 data at /mnt/ccp4data, projects at /mnt/projects'; exec bash"]

  # PostgreSQL Database (optional - for production-like setup)
  db:
    image: postgres:15-alpine
    profiles:
      - postgres  # Only starts with: docker compose --profile postgres up
    ports:
      - "${DB_PORT:-5432}:5432"
    environment:
      - POSTGRES_USER=${DB_USER:-ccp4i2}
      - POSTGRES_PASSWORD=${DB_PASSWORD:-ccp4i2}
      - POSTGRES_DB=${DB_NAME:-ccp4i2}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-ccp4i2}"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

volumes:
  postgres_data:

networks:
  default:
    name: ccp4i2-network
