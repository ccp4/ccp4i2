"""
    pipelines/phaser_pipeline/wrappers/phaser_MR/script/phaser_MR_gui.py
    Copyright (C) 2014 Newcastle University
    Author: Martin Noble
    
    """

import pickle
from qtgui.CCP4TaskWidget import CTaskWidget
from PySide2 import QtCore
from pipelines.phaser_pipeline.wrappers.phaser_MR.script import phaser_MR

#-------------------------------------------------------------------
class phaser_MR_AUTO_gui(CTaskWidget):
    #-------------------------------------------------------------------
    
    # Subclass CTaskWidget to give specific task window
    TASKNAME = 'phaser_MR_AUTO'
    TASKVERSION = 0.1
    TASKMODULE='None'
    TASKTITLE='Molecular Replacement - Phaser'
    DESCRIPTION = '''Molecular replacement (Phaser)'''

    def __init__(self,parent):
        CTaskWidget.__init__(self,parent)

    def setDefaultParameters(self):
        # Reimplement in tasks to set initial parameters
        # read ccp4/src/phaser/source/phaser/defaults for defaults
        pass

    def drawContents(self):
        #Here deal with clones of legacy tasks where the logic of selecting I vs F was different POSSIBILITIES:
        if self.container.inputData.F_OR_I.isSet() and self.container.inputData.F_OR_I.__str__() == 'I' and self.container.inputData.I_SIGI.isSet():
            self.container.inputData.inputData.F_SIGF = self.container.inputData.inputData.I_SIGI
            self.container.inputData.inputData.I_SIGI.unSet()
        self.setProgramHelpFile('phaser')
        self.drawPhaserFrontPage()
        self.openFolder(folderFunction='knownStructure', title='Known structure',drawFolder=self.drawPhaserKnownStructureFolder)
        self.openFolder(folderFunction='keywords', title='Keywords', drawFolder=self.drawPhaserKeywordsFolder)
    
    def drawPhaserKeywordsFolder(self):
        self.createLine(['label', 'Show parameters at ', 'widget', 'EXPERT_LEVEL', 'label', ' level'])
        self.container.guiParameters.EXPERT_LEVEL.dataChanged.connect( self.toggleExpertLevels)
        # exclude these as either need list widget or already in non-autogenerated tabs.
        self.excludedSections = phaser_MR.phaser_MR.excludedSections
        self.excludedKeywords =  phaser_MR.phaser_MR.excludedKeywords
        self.drawKeywords(container=self.container.keywords, excludedKeywords=self.excludedKeywords)
    
    def drawPhaserKnownStructureFolder(self):
        #Open a folder to deal with UI for known solutions
        self.createLine(['advice','Files containing solutions from a previous run of phaser can be input here'])
        self.createLine(['advice','BEWARE - ensemble names must correspond to those used in the Ensemble list'])
        self.createLine(['advice','If a valid file is selected here, the elements to extract for this run can be changed below'])
        self.createLine(['widget', '-browseDb', True, 'RFILEIN'], toggle=['MODE_TY', 'open',['MR_FTF']]) # Now we come back in here.
        self.createLine(['widget', '-browseDb', True, 'SOLIN'], toggle=['MODE_TY', 'close',['MR_FTF']])
        self.container.inputData.SOLIN.dataChanged.connect( self.handleSelectSolFile)
        self.container.inputData.RFILEIN.dataChanged.connect( self.handleSelectRfile)
        self.createLine(['advice',''])
        self.createLine(['widget', '-title', 'Elements of the sol file selected above','USINGSOLELEMENTS'], toggleFunction=[self.shouldDrawSollist,['SOLIN', 'RFILEIN']])
        self.getWidget('USINGSOLELEMENTS').setListVisible(visible=True)
        self.getWidget('USINGSOLELEMENTS').setEditorVisible(visible=False)


    def drawReflections(self):
        self.createLine(['widget', 'F_SIGF'])
        self.createLine(['label','Use Is or Fs', 'widget', 'F_OR_I', 'label', 'Resolution', 'stretch',
                         'widget', 'RESOLUTION_LOW', 'widget', 'RESOLUTION_HIGH', 'label', 'Spacegroups', 'stretch', 
                         'widget', 'SGALT_SELECT',] )
        self.container.inputData.F_SIGF.dataChanged.connect( self.F_SIGFchanged)
        self.F_SIGFchanged()

    def drawReflectionPanel(self):
        self.createLine(['subtitle', 'Reflections'])
        self.openSubFrame(frame=True)
        self.drawReflections()
        self.drawSGChoice()
        self.closeSubFrame()

    def drawPhases(self):
        self.createLine(['widget', 'ABCD'])
        self.createLine(['widget', 'FPHI'])

    def drawPhasePanel(self):
        self.openSubFrame(frame=True, toggle=['TARG_TRAN', 'open', 'phased'])
        self.createLine(['subtitle', 'Phases'])
        self.drawPhases()
        self.closeSubFrame()
    
        
    def drawSGChoice(self):
        self.setToolTip('SGALT_TEST','Enter a list of space-separated spacegroups')
        self.createLine(['widget', 'SGALT_TEST' ], toggle=['SGALT_SELECT', 'open',['LIST']])
        #The validity of the SGALT_TEST widget contents are dependent on SGALT_SELECT
        self.container.inputData.SGALT_SELECT.dataChanged.connect(self.getWidget('SGALT_TEST').validate)

    def drawCompositionPanel(self):
        self.createLine(['tip','Phaser uses this for maximum likelihood and to suggest number of copies in the asymmetric unit','subtitle', 'Composition' ])
        self.openSubFrame(frame=True)
        self.setMenuText('COMP_BY', {'DEFAULT':'Use protein average solvent content',
                                     'MW':'Provided as molecular weights of protein and nucleic acid',
                                     'ASU':'Provided as full specification by sequence'})
        self.createLine(['tip','Phaser uses this for maximum likelihood and to suggest number of copies in the asymmetric unit','label', 'Composition of asymmetric unit:','stretch','widget','COMP_BY'])
        self.container.inputData.COMP_BY.dataChanged.connect(self.handleCOMP_BY)
        self.createLine(['label', '\n '], toggle=['COMP_BY','open',['DEFAULT']])
        self.createLine(['widget','ASUFILE' ], toggle=['COMP_BY','open',['ASU']])
        self.createLine(['label','Molecular weight (Da) of protein in the ASU','stretch','widget', 'ASU_PROTEIN_MW' ], toggle=['COMP_BY','open',['MW']])
        self.createLine(['label','Molecular weight (Da) of nucleic acid','stretch','widget', 'ASU_NUCLEICACID_MW' ], toggle=['COMP_BY','open',['MW']])
        self.closeSubFrame()

    def drawPhaserFrontPage(self):
        self.openFolder(folderFunction='inputData')
        # KJS: New drop down menu (uncomment to add trans/rot only modes - when finished !!)
        self.createLine(['widget', 'MODE_TY'])
        self.container.inputData.MODE_TY.dataChanged.connect(self.handleMODE_TY)
        self.drawReflectionPanel()
        self.drawPhasePanel()
        self.drawCompositionPanel()
        #Special widget for the input ensemble(s)
        self.createLine(['subtitle','Search model(s)'])
        self.openSubFrame(frame=True)
        self.createLine(['widget', '-title', 'Click "Show list" if more than one copy or more than one search model', 'ENSEMBLES'])
        self.closeSubFrame()
        self.handleCOMP_BY()

    @QtCore.Slot()
    def handleSelectSolFile(self):
        #Empty the list of solutions to use
        elements = self.container.inputData.USINGSOLELEMENTS
        while len(elements) > 0:
            elements.remove(elements[-1])
        if self.container.inputData.SOLIN.isSet():
            with open(str(self.container.inputData.SOLIN.fullPath),'r') as file:
                import phaser
                resultObject = pickle.load(file)
                for solution in resultObject:
                    label = str(len(elements)) + ': '
                    for property in ['HALL', 'LLG', 'R', 'TFZ']:
                        value = getattr(solution,property,None)
                        if value is not None:
                            if property == 'HALL':
                                label += ('Spacegroup : '+str(value)+' - ')
                            else:
                                label += (property+' {0:.2f} '.format(float(value)) + ' ')
                    elements.append(elements.makeItem())
                    elements[-1] = label
                #for nd in solution.KNOWN:
                #componentNode = etree.SubElement(solutionNode,'COMPONENT')
                #node = self.subElementWithNameAndText(componentNode,'modlid',str(nd.getModlid()))
        self.validate()
        #Following update wil only work if the widget is "active" (i.e. interface is drawn as before the task is run)
        try: self.getWidget('USINGSOLELEMENTS').updateViewFromModel()
        except: pass
        
    @QtCore.Slot()
    def handleSelectRfile(self):
        #Empty the list of solutions to use
        elements = self.container.inputData.USINGSOLELEMENTS
        while len(elements) > 0:
            elements.remove(elements[-1])
        if self.container.inputData.RFILEIN.isSet():
            with open(str(self.container.inputData.RFILEIN.fullPath),'r') as file:
                import phaser
                resultObject = pickle.load(file)
                for solution in resultObject:
                    for rlist in solution.RLIST:
                        label = str(len(elements)) + ': '
                        for property in ['RFZ', 'DEEP']:
                            value = getattr(rlist,property,None)
                            if value is not None:
                                if property == 'DEEP':
                                    label += ('Deep Search: '+str(value))
                                else:
                                    label += (property+' {0:.2f} '.format(float(value)) + ' ')
                        elements.append(elements.makeItem())
                        elements[-1] = label
        self.validate()
        #Following update wil only work if the widget is "active" (i.e. interface is drawn as before the task is run)
        try: self.getWidget('USINGSOLELEMENTS').updateViewFromModel()
        except: pass


    @QtCore.Slot()
    def handleCOMP_BY(self):
        self.container.inputData.ASUFILE.setQualifiers({'allowUndefined':(str(self.container.inputData.COMP_BY) != "ASU")})
        self.validate()
    
    @QtCore.Slot()
    def handleMODE_TY(self):
        if self.container.inputData.MODE_TY == 'MR_FTF':
            self.container.inputData.RFILEIN.setQualifiers({'allowUndefined':False,'mustExist':True})
            self.container.inputData.SOLIN.setQualifiers({'allowUndefined':True,'mustExist':False})
        elif self.container.inputData.MODE_TY in ['MR_PAK', 'MR_RNP']:
            self.container.inputData.SOLIN.setQualifiers({'allowUndefined':False, 'mustExist':True})
            self.container.inputData.RFILEIN.setQualifiers({'allowUndefined':True,'mustExist':False})
        else:
            self.container.inputData.RFILEIN.setQualifiers({'allowUndefined':True,'mustExist':False})
            self.container.inputData.SOLIN.setQualifiers({'allowUndefined':True,'mustExist':False})
        self.validate()

    def shouldDrawSollist(self):
        return (self.container.inputData.SOLIN.isSet() or self.container.inputData.RFILEIN.isSet())
        
    def isValid(self):
        #Here override logic of whether this is a valid task to allow for CSeqDataFile from the
        #CASUComponentList being required ONLY IF COMP_BY has the value "ASU"
        invalidElements = CTaskWidget.isValid(self)
        from core import CCP4ModelData, CCP4XtalData
        widgLib = {"COMP_BY":"Not set yet"}
        self.getParams(widgLib)
        if not self.container.inputData.COMP_BY == "ASU":
            invalidElements = [invalidElement for invalidElement in invalidElements if (type(invalidElement) != CCP4XtalData.CAsuComponent and type(invalidElement) != CCP4ModelData.CSeqDataFile)]
        
        #Length of "solution elements" list can take any value if SOLIN is not set
        if not self.container.inputData.SOLIN.isSet():
            if self.container.inputData.USINGSOLELEMENTS in invalidElements:
                invalidElements.remove(self.container.inputData.USINGSOLELEMENTS)
        return invalidElements

    @QtCore.Slot()
    def F_SIGFchanged(self):
        self.container.inputData.F_SIGF.setContentFlag(reset=False)
        #Peak to see if we can make Imean, SIGImean
        canConvertString, toType = self.container.inputData.F_SIGF.conversion(3)
        if canConvertString == 'no':
            self.container.inputData.F_OR_I.setQualifiers({'enumerators':['F'],'menuText':['F']})
            self.container.inputData.F_OR_I.set('F')
        else:
            self.container.inputData.F_OR_I.setQualifiers({'enumerators':['F','I'],'menuText':['F','I']})
        try:
            self.getWidget('F_OR_I').populateComboBox(self.container.inputData.F_OR_I)
            self.getWidget('F_OR_I').updateViewFromModel()
        except:
            pass
        self.validate()
        
    def drawKeywords(self, container, excludedKeywords):
        for name, param in [(name, getattr(container, name)) for name in container.dataOrder() if name not in self.excludedSections]:
            if len(param.dataOrder()) > 0:
                includedKeywords = [name for name in param.dataOrder() if name not in self.excludedKeywords]
                phaserMode = param.qualifiers('guiDefinition')['phaserMode'].split(',') if not '*' in param.qualifiers('guiDefinition')['phaserMode'].split(',') and not 'MR*' in param.qualifiers('guiDefinition')['phaserMode'].split(',') else [str(self.container.inputData.MODE_TY)]
                if param.qualifiers('guiDefinition').get('expertLevel', None) is not None:
                    toggleFunction = [self.expertLevelToggleFunction(int(param.qualifiers('guiDefinition')['expertLevel']), phaserMode), ['EXPERT_LEVEL', 'MODE_TY']]
                else:
                    toggleFunction = [self.expertLevelToggleFunction(None, phaserMode), ['EXPERT_LEVEL', 'MODE_TY']]
                if param.qualifiers('guiLabel') is not NotImplemented:
                    title = param.qualifiers('guiLabel')
                    self.openSubFrame(frame=True, title=title, tip='', toggleFunction=toggleFunction)
                else:
                    self.openSubFrame(frame=True, toggleFunction=toggleFunction)
                param.setQualifiers({'guiLabel':NotImplemented}) # Suppress advice labels
                self.autoGenerate(container=param, selection={'includeParameters':includedKeywords}, subFrame=False)
                self.closeSubFrame()
            else:
                self.autoGenerate(container=self.container.keywords, selection={'includeParameters':[name]}, subFrame=False)
        # now hide at default expertLevel
        self.toggleExpertLevels()
                        
    def expertLevelToggleFunction(self, expertLevel, phaserMode):
        if expertLevel is not None:
            return lambda : True if int(self.container.guiParameters.EXPERT_LEVEL) >= expertLevel and self.container.inputData.MODE_TY in phaserMode else False
        else:
            return lambda : True if self.container.inputData.MODE_TY in phaserMode else False     

    @QtCore.Slot()
    def toggleExpertLevels(self):     
        container=self.container.keywords
        for name, param in [(name, getattr(container, name)) for name in container.dataOrder() if name not in self.excludedSections]:
            # this should match everything not in a subFrame
            phaserMode = param.qualifiers('guiDefinition')['phaserMode'].split(',') if not '*' in param.qualifiers('guiDefinition')['phaserMode'].split(',') and not 'MR*' in param.qualifiers('guiDefinition')['phaserMode'].split(',') else [str(self.container.inputData.MODE_TY)]
            if len(param.dataOrder()) == 0 and param.qualifiers('guiDefinition').get('expertLevel', None) is not None:
                line = self.getWidget(name).parent()
                expertLevel = int(param.qualifiers('guiDefinition')['expertLevel'])
                if expertLevel <= int(self.container.guiParameters.EXPERT_LEVEL) and self.container.inputData.MODE_TY in phaserMode:
                    #print 'keyword %s shown at expertLevel %d' % (name, int(self.container.guiParameters.EXPERT_LEVEL))
                    line.show()
                else:
                    #print 'keyword %s hidden at expertLevel %d' % (name, int(self.container.guiParameters.EXPERT_LEVEL))
                    line.hide()
            elif len(param.dataOrder()) == 0 and param.qualifiers('guiDefinition').get('expertLevel', None) is None:
                line = self.getWidget(name).parent()
                if self.container.inputData.MODE_TY in phaserMode:
                    line.show()
                else:
                    line.hide()
            else:
                for keyword in [name for name in param.dataOrder() if name not in self.excludedKeywords]:
                    if getattr(param, keyword).qualifiers('guiDefinition').get('expertLevel', None) is not None:
                        line = self.getWidget(keyword).parent()
                        expertLevel = int(getattr(param, keyword).qualifiers('guiDefinition')['expertLevel'])
                        if expertLevel <= int(self.container.guiParameters.EXPERT_LEVEL):
                            # print 'keyword %s shown at expertLevel %d' % (keyword, int(self.container.guiParameters.EXPERT_LEVEL))
                            line.show()
                        else:
                            # print 'keyword %s hidden at expertLevel %d' % (keyword, int(self.container.guiParameters.EXPERT_LEVEL))
                            line.hide()

