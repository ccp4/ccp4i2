<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>Generating Reports</title>
</head>
<body>
<h1>CCP4I2 Generating Reports</h1>

<h3>Contents</h3>
<p>
<br/><a href="#introduction">Introduction</a>
<br/><a href="#xml"/>Handling XML</a>
<br/><a href="#classes">CCP4ReportParser classes</a>
<br/><a href="#filepaths"/>File paths</a>
<br/><a href="#table">Tables</a>
<br/><a href="#graph">Graphs</a>
<br/><a href="#picture">Pictures</a>
<br/><a href="#launch">Launch</a>
<br/><a href="#help">Help</a>
<br/><a href="#otherxml">Accessing other program output</a>
<br/><a href="#customisation">Customising Reports</a>
<br/><a href="#running">Real-time updating reports</a>
<br/><a href="#pipelines">Creating Reports for Pipelines</a>
<br/><a href="#examples">Examples of Python Report Definitions</a>
<br/><a href="#testing">Testing a Python Report Definition</a>
<br/><a href="#appendix a">Appendix A - The Database data accessible from an XRT file</a>
<br/><a href="#appendix b"/>Appendix B - The CCP4mg scene file</a>
<br/><a href="#appendix c"/>Appendix C - Style Guide</a>
</p>


<p>The report generator is a work-in-progress - please let Liz know about any features that you need or ask for examples of how to do some particular thing.</p>

<a name="introduction"/><h3>Introduction</h3>
<p>The layout and content of job reports for CCP4i2 containing text, graphs, tables, pictures and more can be defined in Python.  This supersedes an earlier version of report generation using an XML report template (<i>xrt</i>) that is described <a href="./reports_xrt.html">here</a>. The <i>CCP4ReportParser</i> module provides classes to represent all the features of the report and simple functions to specify the report in minimal code. For each task there should be a sub-class of <i>CCP4ReportParser.Report</i> which is the top-level of the report definition that I will refer to as the Python report definition - <i>prd</i>. </p>
<p>Usually the program or script will output an xml file containing the job-specific data for the report. When the job completes (or otherwise - see below) ccp4i2 instantiates the <i>prd</i> object and passes it a representation of the XML data file. The <i>Report</i> class should construct a tree of <i>Text</i>, <i>Graph</i>, <i>Table</i> etc. objects that represent the required report and substitute data from the XML file (and other sources if necessary) into the definition. The <i>Report.as_html_file()</i> method is then called by the ccp4i2 framework to save the report to an HTML file. Note that the report may contain Qt widgets that can only be displayed in the CCP4i2 browser.  Some extra features such as input/output data and job status are added to the report automatically so need not be specified explicitly in the report code.  In future the functionality could be extended to create alternative file formats.  Note that Appendix C contains a style guide to current best practice.</p>

<p>The <i>prd</i> file can be placed in either the <i>wrapper</i>, <i>pipeline</i> or <i>task</i> directory for the task. At startup ccp4i2 will check for files containing sub-classes of <i>Report</i> and make a lookup table based on the <i>TASKNAME</i> parameter in the <i>prd</i>. If there is an error in the Python file which prevents it being imported when CCP4i2 starts then this is reported to the terminal and the <i>Program print log</i> (under <i>Utilities</i> pull-down menu).  Application developers should not normally need to use it but the function <i>TASKMANAGER().getReportClass()</i> will return the <i>Report</i> sub-class for a given taskname. Within ccp4i2 the <i>Report</i> sub-class is instantiated with two arguments that may determine the sort of output required: <i>jobStatus</i> which currently may have values 'Running', 'Finished', 'Unsatisfactory', or 'Failed' and <i>reportMode</i> which currently may have values None (the default) or 'subjob' which implies the request for a report is for a pipeline sub-job. Currently the 'subjob' request will come from a user clicking a sub-job in the Project Viewer and picking <i>View->Job report</i> from the context menu.  The <i>prd</i> should be customised to support these options.</p>
<p>The report class is should create the output appropriate for the <i>jobStatus</i> which may be:
<br/><b>Finished</b> - the most common case - should create the usual report.
<br/><b>Running</b> - the job is still running and probably this requires generating a short report showing progress (e.g. a graph showing RFactor v. cycle). If this case is supported then a class variable <i>RUNNING</i> should be set <i>True</i> 
<br/><b>Unsatisfactory</b> - the job has completed but without a good scientific result.  The report may be similar to the 'Finished' report but should say what has happened and suggest what to do about it.
<br/><b>Failed</b> - the job has failed; a generic failed job report is usually created by the core system but if the <i>CReport</i> sub-class variable <i>FAILED</i> is set True then the a <i>CReport</i>  sub-class is also created and put at the top of the generic report. In this case a short report on what has failed and what to do about it is appropriate.
</p>
<a name="xml"/><h3>Handling XML</h3>
<p>The CCP4i2 libraries include <a href="lxml.de">lxml</a> which handles XML within Python and provides many tools. For users convenience lxml provides the same api as an earlier <i>etree</i> package so you are more likely to see the word 'etree' rather than 'lxml' in code. The internal representation of XML is as an <a href="lxml.de/tutorial.html">etree.Element</a> for which there is brief (but likely enough for ccp4i2 developers) documentation within the Python documentation <a href="http://docs.python.org/2/library/xml.etree.elementtree.html#module-xml.etree.ElementTree">here</a> (scroll down for Element).  The most useful tool is <a href="http://www.w3schools.com/xpath">xpath</a> which queries the XML.</p>
<p>In order to tidy up the report definition code there is a small CCP4i2 extension to <i>etree.Element</i> called <i>CCP4ReportParser.SearchableElement</i> with the following methods (where input <i>path</i> is an xpath expression - see the <a href="http://www.w3schools.com/xpath">xpath</a> docs). :</p>
<table border="1">
  <tr><td>select</td><td>path</td><td>Return the content (element.text or attribute) of the first item satisfying the expression. Return empty string if nothing satisfies </td></tr>
  <tr><td>ifSelect</td><td>path,default=False</td><td>Return a Boolean from first item satisfying the expresion or return the default</td></tr>
  <tr><td>haspath</td><td>path</td><td>Return True/False if there is an item satisfying the expression</td></tr>
  <tr><td>xpath0</td><td>path</td><td>Return the first element satisfying the expression or return None</td></tr>
  <tr><td>xpath1</td><td>path</td><td>Return the first element satisfying the expression or return an empty element (tag ='dummy')</td></tr>
</table>

<p>To use these extensions the XML file must be loaded using a customised parser. The 'standard' job XML output is passed to the Report object already appropriately parsed but if you wish to load any other XML files use the method <i>Report.loadXmlFile(fileName)</i></p>

<a name="classes"><h3>CCP4ReportParser classes</h3>
<p>The report definition will have a tree structure with a <i>Report</i> object as the root node. The child objects may be either container objects that have children or content objects that represent features such as text or tables.<i>Report</i> is a sub-class of <i>Container</i> (which should not be used directly).  The other useful sub-classes are <i>Fold</i> which creates a 'fold' in the report whose contents can be displayed or hidden by clicking on a title line and <i>GraphGroup</i> or <i>PictureGroup</i> which groups together multiple graphs or pictures to be displayed in the same widget. There are several other <i>Container</i> types that are used to support the logic in the XRT report definitions but these are not necessary to support Python definitions.</p>
<p>The <i>__init__</i> method of all classes have three arguments that pass along some basic data:</p>
<table border="1">
<tr><td>xrtnode</td><td>etree.Element</td><td>Supports XRT file method of report definition</td></tr>
<tr><td>xmlnode</td><td>etree.Element</td><td>The job XML output</td></tr>
<tr><td>jobInfo</td><td>Python dictionary</td><td>Job information from the database</td></tr>
</table>
<p>There are also optional arguments to specify the <i>id</i> or <i>class</i> attribute for the html element that may be useful for customising the appearance of the report. Note that <i>class</i> is a reserved word in Python so the Python argument is called <i>class_</i> and also some report features have a fixed <i>class</i> attribute needed to support the standard functionality.</p>
<p>The Python report definition should usually begin:</p>
<pre>
from report.CCP4ReportParser import *
from core.CCP4ErrorHandling import *

class my_task_report(Report):
  # Specify which gui task and/or pluginscript this applies to
  TASKNAME = 'my_task'
  def __init__(self,xmlnode=None,jobInfo={},**kw):
    Report. __init__(self,xmlnode=xmlnode,jobInfo=jobInfo,**kw)
    if self.errorReport().maxSeverity()>SEVERITY_WARNING:
      print 'FAILED instantiating my_task report generator'
      self.errorReport().report()
      return
    graph = self.addGraph( title="The best results" , select="//results/best" )
</pre>
<p>The task-specific report object will be instantiated with appropriate <i>xmlnode</i> and <i>jobInfo</i> data by the ccp4i2 framework and must pass these arguments onto the <i>Report</i> sub-class which will hand them on to its child objects. The <i>xrtnode</i> argument is not used in the Python api and can be ignored.<p>
<p>After calling <i>Report.__init__()</i> it is a good idea to check for errors - <i>Container.errorReport()</i> will return an instance of <a href="./error_handling.html"><i>CCP4ErrorHandling.CErrorReport</i></a> which is a list of errors recorded in the <i>Report</i> object and any child objects.  If there are any errors with severity greater than warning (likely to be failing to read a file) then it is best to stop and, to aid debugging, you can print out the error report with the <i>CErrorReport.report()</i> method.<p>
<p>It is a good idea to split the report definition into different methods for each element of the report rather than put the full definition in the __init__() method. This will make it easier to change the report structure or provide customised reports in different context (e.g. a 'Running' report may contain just a graph showing progress per cycle). See the <a href="../../tasks/buccaneer_build_refine/buccaneer_build_refine_report.py">buccaneer_build_refine</a> for an example of this.</p>
<p>The application developer should usually create a new object using  methods such as <i>addGraph()</i> which creates a new object passing on the standard arguments, adds the new object to its list of children and returns the new object.</p>
<p>The table below lists the <i>addWhatever</i> methods and their arguments in addition to the three standard and two optional (<i>id</i> and <i>class_</i>) arguments. The methods of the individual content classes are also included.</p>

<table border="1">
<tr><td><b>Container<b></td><td>-</td><td>-</td><td>Base container class - should not be used itself</td></tr>
<tr><td>__init__</td><td>-</td><td>-</td><td>-</td></tr>
<tr><td>-</td><td>xrtnode</td><td>etree.Element</td><td>Supports XRT file method of report definition</td></tr>
<tr><td>-</td><td>xmlnode</td><td>etree.Element</td><td>The job XML output</td></tr>
<tr><td>-</td><td>jobInfo</td><td>Python dictionary</td><td>Job information from the database</td></tr>
<tr><td>loadXmlFile</td><td-></td><td>-</td><td>-</td><td>Read and parse an XML file to return an etree.Element</td></tr>
<tr><td>-</td><td>fileName</td><td>string</td><td>File path</td></tr>
<tr><td>addDiv</td><td>-</td><td>-</td><td>Return a new <i>Div</i> object</td></tr>
<tr><td>addFold</td><td>-</td><td>-</td><td>Return a new <i>Fold</i> object</td></tr>
<tr><td>-</td><td>label</td><td>string</td><td>Label to appear on fold bar</td></tr>
<tr><td>-</td><td>initiallyOpen</td><td>Boolean</td><td>Determines whether the <i>Fold</i> object is initially  open</td></tr>
<tr><td>-</td><td>brief</td><td>string</td><td>A short label to appear on top bar of report display</td></tr>
<tr><td>addGraphGroup</td><td>-</td><td>-</td><td>Return a new <i>GraphGroup</i> object</td></tr>
<tr><td>-</td><td>launcher</td><td>string</td><td>Do not display the graphs in the report but display a button with this label that will launch the graph viewer displaying the graphs</td></tr>
<tr><td>addPictureGroup</td><td>-</td><td>-</td><td>Return a new <i>PictureGroup</i> object (not fully implemented)</td></tr>
<tr><td>addText</td><td>-</td><td>-</td><td>Add text to report</td></tr>
<tr><td>-</td><td>text</td><td>string</td><td>text to add to report - &lt;p&gt; tags will be added if text is not well-formed xml</td></tr>
<tr><td>-</td><td>select</td><td>string</td><td>xpath string to select text from the xml input</td></tr>
<tr><td>addTable</td><td>-</td><td>-</td><td>Add a table to the report</td></tr>
<tr><td>-</td><td>select</td><td>string</td><td>xpath expression to select list on items in xml input</td></tr>
<tr><td>-</td><td>excludeIfDataMissing</td><td>Boolean</td><td>If true exclude any column from table for which data not found in xml</td></tr>
<tr><td>-</td><td>transpose</td><td>Boolean</td><td>If true print out table transposed with row headers</td></tr>
<tr><td>-</td><td>help</td><td>string</td><td>-</td></tr>
<tr><td>addGraph</td><td>-</td><td>-</td><td>Add a graph to the report or graphgroup</td></tr>
<tr><td>-</td><td>select</td><td>string</td><td>xpath expression to select list on items in xml input</td></tr>
<tr><td>-</td><td>title</td><td>string</td><td>Title for the graph</td></tr>
<tr><td>-</td><td>help</td><td>string</td><td>-</td></tr>
<tr><td>-</td><td>launcher</td><td>string</td><td>Do not display the graph in the report but display a button with this label that will launch the graph viewer displaying the graph</td></tr>
<tr><td>addPicture</td><td>-</td><td>-</td><td>Add a picture to the report</td></tr>
<tr><td>-</td><td>scene</td><td>string</td><td>text ccp4mg scene description</td></tr>
<tr><td>-</td><td>sceneFile</td><td>string</td><td>Full path filename for file containing ccp4mg scene description</td></tr>
<tr><td>-</td><td>label</td><td>string</td><td>Label for the picture</td></tr>
<tr><td>addCopy</td><td>-</td><td>-</td><td>Return a Copy object that copies xml 'as-is' into the report</td></tr>
<tr><td>-</td><td>select</td><td>string</td><td>xpath expression to specify element in task XML</td></tr>
<tr><td>addLaunch</td><td>-</td><td>-</td><td>Return a Launch object that puts a Launch button in the report</td></tr>
<tr><td>-</td><td>label</td><td>string</td><td>Label for launch button</td></tr>
<tr><td>-</td><td>taskName</td><td>string</td><td>Name of task to be launched</td></tr>
<tr><td>addHelp</td><td>-</td><td>-</td><td>Add help link to report</td></tr>
<tr><td>-</td><td>label</td><td>string</td><td>Label for help link</td></tr>
<tr><td>-</td><td>ref</td><td>string</td><td>path of file to link to</td></tr>
<tr><td>addReference</td><td>-</td><td>-</td><td>Add bibliographic reference to appear in 'References' section of report</td></tr>
<tr><td>-</td><td>authors</td><td>string</td><td>List of authors</td></tr>
<tr><td>-</td><td>articleTitle</td><td>string</td><td>Title of article</td></tr>
<tr><td>-</td><td>source</td><td>string</td><td>Source of article</td></tr>
<tr><td>-</td><td>articleLink</td><td>string</td><td>link to article on the web</td></tr>

<tr><td><b>Report(Container)</b></td>-<td></td><td>-</td><td>Obligatory top container for a report</td></tr>
<tr><td>__init__</td><td>-</td><td>-</td><td>-</td></tr>
<tr><td>-</td><td>standardise</td><td>Boolean</td><td>If true add the standard features (input/output files etc) to the report</td></tr>
<tr><td>-</td><td>xmlFile</td><td>string</td><td>File path for XML file to be read and used as xmlnode</td></tr>
<tr><td>-</td><td>jobId</td><td>string</td><td>jobId for a previously run job whose info can be extracted from database and used as jobInfo</td></tr>
<tr><td>-</td><td>htmlBase</td><td>string</td><td>Optional URL for <i>report_files</i> directory containing css and js files - default is for CCP4i2 HTTP server</td></tr>
<tr><td>-</td><td>cssFile</td><td>string</td><td>Optional basename of a css file specific for this report</td></tr>
<tr><td>-</td><td>jsFile</td><td>string</td><td>Optional basename of a js file specific for this report</td></tr>
<tr><td>-</td><td>cssVersion</td><td>string</td><td>The version sub-directory of ccp4i2/report_files used to provide css and js files - defaults to the latest version</td></tr>


<tr><td>as_etree</td><td>-</td><td>-</td><td>Return an etree representation of the html report</td></tr>
<tr><td>as_html</td><td>-</td><td>-</td><td>Return html text representation of the report</td></tr>
<tr><td>as_html_file</td><td>-</td><td>-</td><td>Write html representation to a file</td></tr>
<tr><td>-</td><td>fileName</td><td>string</td><td>Full path file name</td></tr>
<tr><td>-</td><td>pretty_print</td><td>Boolean</td><td>If true output in 'pretty print' more readable format</td></tr>

<tr><td><b>Div(Container)</b></td><td>-</td><td>-</td><td>Create an html div element - used to group other elements</td></tr>
<tr><td>__init__</td><td>-</td><td>-</td><td>-</td></tr>

<tr><td><b>Fold(Container)</b></td><td>-</td><td>-</td><td>Folder in report that can be opened/closed by clicking title line</td></tr>
<tr><td>__init__</td><td>-</td><td>-</td><td>-</td></tr>
<tr><td>-</td><td>label</td><td>string</td><td>Label for title line</td></tr>
<tr><td><b>GraphGroup(Container)<b></td><td>-</td><td>-</td><td>Group graphs that appear in one graph widget</td></tr>
<tr><td><b>PictureGroup(Container)</b></td>-<td>-</td><td>-</td><td>Group of pictures to be displayed together and put in one CCP4mg presentation. <b>Not fully implemented.</b></td></tr>

<tr><td><b>Table</b></td><td>-</td><td>-</td><td>Display a table</td></tr>
<tr><td>addData</td><td>-</td><td>-</td><td>Specify one column of data for table</td></tr>
<tr><td>-</td><td>title</td><td>string</td><td>column title</td></tr>
<tr><td>-</td><td>subTitle</td><td>string</td><td>sub-title for tables with nested headers</td></tr>
<tr><td>-</td><td>select</td><td>string</td><td>xpath expression to select data elements from xml</td></tr>
<tr><td>-</td><td>data</td><td>list of floats/ints</td><td>List of data elements</td></tr>

<tr><td><b>Graph</b></td><td>-</td><td>-</td><td>Display a graph</td></tr>
<tr><td>addData</td><td>-</td><td>-</td><td>Add the data for one plot on the graph</td></tr>
<tr><td>-</td><td>xmldata</td><td>List of etree.Elements</td><td>List of elements (probably in the task XML) from which the plot data is taken</td></tr>
<tr><td>-</td><td>title</td><td>string</td><td>A legend for the plot</td></tr>
<tr><td>-</td><td>select</td><td>string</td><td>An xpath expression to extract data from sub-elements of xmldata</td></tr>
<tr><td>-</td><td>expr</td><td>string</td><td>A Python expression to be applied to each data element to transform it</td></tr>
<tr><td>-</td><td>data</td><td>List of int/float</td><td>The data to be plotted</td></tr>
<tr><td>addTable</td><td>-</td><td>-</td><td>Add a table of data taken from the XML as a space-separated table</td></tr>
<tr><td>-</td><td>xmlnode</td><td>etree.Element</td><td>An element (probably in the task XML) containing table of data</td></tr>
<tr><td>-</td><td>select</td><td>string</td><td>xpath expression to sub-element of xmlnode which is the actual table</td></tr>
<tr><td>-</td><td>headers</td><td>string</td><td>xpath expression to a list of sub-elements containing the column header</td></tr>
<tr><td>addPlot</td><td>-</td><td>-</td><td>Add a plot definition to the graph</td></tr>
<tr><td></td><td>xmlnode</td><td>etree.Element</td><td>An element (probably in the task XML) containing instructions for one plot</td></tr>
<tr><td>-</td><td>select</td><td>string</td><td>xpath expression to sub-element of xmlnode which is the actual plot</td></tr>
<tr><td>-</td><td>plot</td><td>string</td><td>An etree.Element which is the plot definition</td></tr>
<tr><td>-</td><td>plotFile</td><td>string</td><td>The full path of file containing a plot definition</td></tr>
<tr><td>addPlotObject</td><td>-</td><td>-</td><td>Return a new <i>Plot</i> object.</td></tr>
<tr><td><b>Plot</b></td><td>-</td><td>-</td><td>Define one plot to appear on a graph</td></tr>
<tr><td>append</td><td>-</td><td>-</td><td>Add an element to the XML plot definition</td></tr>
<tr><td>-</td><td>tag</td><td>string</td><td>The XML element tag</td></tr>
<tr><td>-</td><td>text</td><td>string</td><td>The XML element text</td></tr>
<tr><td>-</td><td>*</td><td>*</td><td>Additional arguments interpreted as XML element attributes</td></tr>
<tr><td>validate</td><td></td><td></td><td>Validate the plot definition against the schema</td></tr>
<tr><td><b>Picture</b></td><td>-</td><td>-</td><td>Display a picture</td></tr>

</table>


<a name="filepaths"/><h4>File paths</h4>
<p>Specification of file paths can begin '$CCP4I2' for files in the CCP4i2 distribution directory.</p>


<a name="tables"/><h4>Tables</h4>
<p>The table layout and headers are specified by the <i>Container.addTable()</i> and <i>Table.addData()</i> methods, the values are extracted from the task XML. The table object has two optional arguments, <i>transpose</i> changes the orientation of the table, and <i>select</i>, an XPATH expression which extracts a list of elements containing row data.  Each extracted element is expected to contain all the information for a single table row. Occasionally the data in the task XML may not be in a suitable form for this, in which case the argument is omitted. The <i>addData()</i> method can take four arguments: <i>title</i>, <i>subtitle</i>, <i>expr</i> and <i>select</i>. The <i>title</i> argument gives the column header. The <i>subtitle</i> argument allows tables with nested headers. The <i>select</i> argument specifies an xpath expression to select the data to be displayed. If the <i>addTable()</i> <i>select</i> argument has selected a list of row elements then this should specify a unique element within that row element. If  <i>addTable()</i> has no <i>select</i> argument, the select should return a list of elements which will become the column values. In the latter form there is no guarantee columns will be of the same length. The <i>expr</i> argument enables a python expression to be applied to the value before display.<p>
<p>Alternatively the Python script can extract and process the data as it needs and then load it using the <i>data</i> argument of the <i>addData()</i> method; this should be a list of values for a column of data.</p>

<a name="graph"/><h4>Graphs</h4>
 <p>This is an interface to the <b>pimple</b> graph display program which will be shown inline within the report. <i>pimple</i> can display multiple plots in one window with two combo-boxes to allow selection of the current plot.  The left-hand combo-box will select a data table and the right-hand box will select between views on that table. The <i>Graph</i> object can only specify one data table with, optionally, multiple views specified by the <i>addPlot</i> block. Multiple <i>Graph</i> objects can be grouped in a <i>GraphGroup</i> object to be displayed in the same <i>pimple</i> instance with the <i>title</i> arguments from each <i>addGraph()</i> appearing in the left-hand combo-box.</p>

<p>The plotting directives for <i>pimple</i> can be entered as XML using the <i>addPlot()</i> method or they can be specified in Python using the <i>addPlotObject()</i> method. The latter returns a <i>Plot</i> object which can then be populated using the <i>append()</i> method; this is a totally generic method for defining the XML definition from Python with arguments that specify the tag, text and an arbitrary number of attributes. The XML data structure for a table and associated graphs is described <a href="./pimple.html">here </a>. The <i>Plot.validate()</i> method will validate the generated XML against the schema <a href="../../pimple/CCP4ApplicationOutput.xsd">ccp4i2/pimple/CCP4ApplicationsOutput.xsd</a> and returns a list of errors as a <a href="./error_handling.html">CErrorReport</a>. There is an example of this in <a href="../../tasks/buccaneer_build_refine/buccaneer_build_refine_report.py">buccaneer_build_refine</a>.
<p>There can be multiple <i>Plot</i>s within one <i>Graph</i> - this implies that multiple views of the same data table are possible and are listed in the right-hand combo-box in <i>pimple</i>.</p>
<p>If the graph is instantiated with <i>launcher</i> parameter set then the graph will not be shown in the report but there will be a button to launch the graph viewer.  The label on the button will be the value of <i>launcher</i>.

<a name="picture"/><h4>Pictures</h4>
<p>This makes a picture in the report with buttons to launch either CCP4mg or Coot with the same view. The picture is generated by CCP4mg which runs in background without appearing on the computer screen.  CCP4mg needs a <i>scene.xml</i> file to specify what it is to display and save as a picture. The scene file specifies which data files (either coordinates or maps) are to be loaded and how they should be drawn. The drawing specification can be either a <i>simple scene</i> or generated using the CCP4mg Picture Wizard. Many other aspects of the display can also be specified using CCP4mg's usual XML. The template for the scene.xml file should be given as the <i>scene</i> argument or provided in a separate file that is specified by the <i>sceneFile</i> argument. Typically some parameters such as filenames need to be substituted into the scene.xml template and this should be done using <i>database</i> or <i>select</i> attributes to specify the source of the substituted data. </p>
<!--
<p>A simple example is in the <i>buccaneer.xrt</i> where a picture element uses an <i>sceneFile</i> element to specify a separate xrt file which contains the template for a CCP4mg scene file:</p>
<pre>
&lt;xrt:picture label="Final structure" >
&lt;xrtInsert filename=$CCP4I2/tasks/buccaneer/buccaneer.scene.xrt/>
&lt;/xrt:picture>
</pre>
-->
<p>The contents of the CCP4mg scene file are explained in <a href="#appendix b">Appendix B</a>.
 

<a name="launch"/><h4>Launch</h4>
<p>Insert a button in the report to launch another viewer. Currently supports CCP4mg and Coot. The initial view in CCP4mg can be set by specifying a <i>pictureDefinitionFile</i> argument. </p>


<a name="help"/><h4>Help</h4>
<p>This puts a <i>Help</i> link by tables, graphs etc. and is highly recommended!  The <i>ref</i> argument  gives the link reference which can be a file path starting with an environment variable (eg $CCP4I2) and the appropriate full path will be substituted into the html.</p>

<a name="references"/><h4>Bibliographic references</h4>
<p>A section of references is automatically appended to a report provided that the references information has been provided. It is necessary for task developers to provide MedLine and BibTeX format references for each task as described <a href="./pipelines.html#bibliographic_references">here</a>. The <i>Report</i> sub-class should call the <i>addTaskReferences()</i> method. If it is called without an argument this method will look for the bibliographic reference files for the current task.  A pipeline report generator will probably need to call this method to get the references for sub-tasks, for example for the buccaneer_build_refine pipeline that uses Refmac the report generator includes:</p>
<pre>
      self.addTaskReferences('buccaneer')
      self.addTaskReferences('prosmart_refmac')
</pre>
<p>Alternatively the information can be provided via the <i>Report.addReference()</i> method but since this implies there is no MedLine or BibTeX formated files available the tools for users to download references will not be available.</p>

<a name="otherxml"/><h3>Accessing other program output</h3>
<p>Within i2, by default, the Report.__init__() is passed the etree representation of one data XML file, <i>program.xml</i> from the top level job directory. If you are creating a report for a pipeline you may need to access data files from sub-jobs or data from other sources. The report generator can access other files using the usual Python functionality but it must know where to find the files.  Within i2 the Report.__init__() is passed a Python dictionary <i>jobInfo</i> which contains some data extracted from the database (see <a href="#appendix a">Appendix A</a>). The most useful thing is <i>jobInfo['fileroot']</i> that is the job directory for the pipeline job.</p>
<p>If you are running in test mode outside i2 <i>jobInfo</i> is empty.  See <a href="#testing">Testing</a> on how you should run one job and note the <i>jobId</i> that you then pass into the report and it gets the <i>jobInfo</i> from the database.</p>
<p>A potential problem is that the report class does not know exactly which subjobs were run  - an alternative approach is for the pipeline script to merge the subjob xml files - there is an example in <a href="../../tasks/buccaneer_build_refine/buccaneer_build_refine_report.py">pipelines/bucref/script/buccaneer_build_refine</a>. This example uses xpath to pick bits out of the Refmac subjobs xml output but you could just aim to put everything in one file with a structure like:</p>
<pre>
&lt;thewholelot&gt;
&lt;pointless&gt;
   copy everything from subjob output
&lt;/pointless&gt;
&lt;aimless&gt;
  copy everything from subjob output
&lt;/aimless&gt;
   and more
&lt;/thewholelot&gt;
</pre>

<p>It is the responsibility of the developer to deal with the output from different versions of CCP4i2 tasks and the different programs.  Ideally the report code in any release must be able to deal with the output from any earlier version of the task or programs - so I'd suggest:</p>
<ul>
<li>program output has some meta-data header that includes the program version</li>
<li>put each element definition (for graph,table,etc) in a separate method - replicate the method if the given element changes significantly</li>
<li>use try,except where the required data might not be available</li>
<li>python tricks such as 'import whatever-3.1 as whatever' could be used to handle big changes</li>
</ul>

<a name="customisation"/><h3>Customising Report Appearance</h3>
<p>The appearance of reports is determined by css and Javascript files that are referenced in the header of the generated html file. Individual report html elements or groups of html elements for selection by Javascript or css can be given <i>id</i> and/or <i>class</i> attributes by using <i>id</i> or <i>class_</i> arguments to the element's <i> __init__</i>  method or to the <i>Container.addWhatever</i> methods. Note the underscore in the  <i>class_</i> argument that is necessary to differentiate from a Python reserved word. For example in the <i>buccaneer_build_refine_report.py</i> there is the line:</p>
<pre>
graph = parent.addGraph( title="Completeness by build-refine cycle", select="//BuccaneerBuildRefineResult/BuildRefineCycle", id = "completenessGraph")
</pre>
<p>This will create a graph element in the html with the id <i>completenessGraph</i>.</p>
<p>By default the css <i>xreport.css</i> and Javascript <i>xreport.js</i> files are referenced in generated html files. These files have a pathname
in the CCP4i2 release such as <i>ccp4i2/docs/report_files/x.y.z/xreport.css</i> where <i>x.y.z</i> is a version directory.Developers may add alternative css or js files but please consider and discuss how your requirements might be met by updating the default files. If you wish to use alternative files then theg the filename (e.g. <i>whatever.css</i>) must be passsed as argument <i>cssFile</i> or <i>jsFile</i> to <i>Report.__init__()</i>.</p>
<p>Future releases of CCP4i2 will retain old <i>report_files</i> version directories in order to support any old report files.  By default the report parser will generate html to use the latest version available unless <i>Report.__init__()</i> class has a <i>cssVersion</i> argument which is set to an earlier version number.  Developers are recommended to set this parameter to the version that they have used in development of the <i>prd</i> and to only update the value after they have tested against any more recent version of <i>report_files</i>. If the <i>cssVersion</i> is set but there is a higher minor version number available then that will be used on the assumption that this minor version number increments are bug-fixes. </p>
<p>CCP4i2 uses an internal HTTP server to serve the files from <i>report_files</i> and it usually expects these to have a URL beginning <i>http://127.0.0.1:43434/report_files</i>.  The port number (default 43434) may change - reports are edited at display time to correct the port number. Old report files which do not use the HTTP server are also be updated to do so.</p>

<a name="running"><h3>Real-time updating reports</h3>
<p>A report can be generated and updated as a job is running - a drawback is that at the moment the entire report is redone so speed is a possible issue and the 'running' report should be not too long - usually an updating graph is ideal. The report class should have the the class parameter <i>RUNNING</i> set true so the system knows to call the report generator as the job is running. The <i>Report.__init__()</i> method is passed a <i>jobStatus</i> argument which will be <i>Running</i> and the appropriate report should be returned.</p>
<p>By default the system watches a running job's <i>program.xml</i> file and when this file changes there is a redraw of the job report. If you require to watch an alternative file then set the class attribute <i>MyReport.WATCHED_FILE</i> to the name of the watched file or a relative path to the file from the job directory.</p>
<a name="pipelines"/><h3>Creating Reports for Pipelines</h3>
<p>In principle a report from a pipeline is no different from a report from a wrapper but a pipeline report may want to incorporate some elements from the sub-job reports. For this to be possible the sub-job report should be written in modular fashion with separate methods for each element in the report. The <i>Report.__init__()</i> method calls the appropriate methods to generate the report dependent on the <i>jobStatus</i> argument which is usually either <i>Finished</i>, <i>Unsatisfactory</i> or <i>Running</i>.  The <i>Report.__init__()</i> method should also handle a <i>jobStatus</i> value of <i>noOutput</i> for which it returns without creating any report elements. For example:

<pre>
class MyWrapperReport(Report):
  def __init__(self,xmlnode=None,jobInfo={},jobStatus=None,**kw):
    Report. __init__(self,xmlnode=xmlnode,jobInfo=jobInfo,**kw)
    if self.errorReport().maxSeverity()>SEVERITY_WARNING:
      print 'FAILED instantiating MyWrapper report generator'
      self.errorReport().report()
      return

    # 'nooutput' mode would be used by another report class that wanted
    # to use some method(s) from this class for its own report
    if jobStatus is not None and jobStatus.lower() == 'nooutput':
      return
    elif jobStatus == 'Running':
      self.completenessGraph(self)
    else:
      self.completenessGraph(self)
      self.details(self)
      self.picture(self)

  def completenessGraph(self,parent):
    graph = parent.addGraph( title="Completeness by cycle", select="//MyWrapper/Cycle" )
    graph.addData (title="Cycle",  select="Number" )
    ...
    ...
</pre>

<p>Note that here the method <i>completenessGraph</i> is passed a reference to <i>self</i> so it will (in the first line) add a graph to <i>self</i> and then go on to add details to that graph.</p>

<p>A pipeline that uses the <i>MyWrapper</i> wrapper and wanted to incorporate elements from the <i>MyWrapperReport</i> could then do:</p>

<pre>
   import MyWrapperReport
   myWrapperXml = self.xmlnode.xpath0('foo/bar')
   myWapperReport = MyWrapperReport.MyWrapperReport(xmlnode=myWrapperXml,jobStatus='noOutput')
   myWapperReport.picture(parent=self)
</pre>
<p>Here we are assuming that the program xml for <i>MyWrapper</i> is embedded in the pipeline xml and can be selected by the xpath 'foo/bar' and this is then passed to<i> MyWrapperReport.__init__()</i> as the argument <i>xmlnode</i>. Alternatively data may come from a separate file that should be passed as the <i>xmlFile</i> argument.   <i>MyWrapperReport.__init__()</i>  is called with <i>jobStatus='noOutput'</i> so that it creates no output. The pipeline report generator can then call the appropriate methods for the report elements that it requires. It passes <i>self</i> as the <i>parent</i> argument so the elements are appended to the pipeline report.</p>

<p>One possible issue with calling Report methods from different places is that the top level of <i>Report.xmlNode</i>, the etree representation of the XML data file, may not be at the same level in the hierarchy and this will make writing xpath selections tricky. The solution may be to either add or remove a top level etree element. Here are two examples assuming we want the top level element to be 'MYWRAPPER'. To remove some redundant parent elements:</p>

<pre>
  if not self.xmlNode.tag == 'MYWRAPPER':
    myWrapperNode = self.xmlNode.xpath0('MYWRAPPER')
    if myWrapperNode is not None:
      self.xmlNode = myWrapperNode
    else:
      print "ERROR no MYWRAPPER node"
</pre>

<p>Alternatively to add an extra parent element:</p>

<pre>
  from lxml import etree
  newNode = etree.Element('NEWNODE')
  newNode.append(self.xmlNode)
  self.xmlNode = newNode
</pre>
  
<a name="examples"/><h3>Examples of Python Report Definitions</h3>
<p>Currently best example:</p>
<br/><a href="../../tasks/buccaneer_build_refine/buccaneer_build_refine_report.py">buccaneer_build_refine</a> which creates 'Running' reports.
<br/>a fragment for <a href="../../test/report_test/pointless_report.py">pointless</a>
<p>Please ask Liz if you would like examples of other specific features.</p>

<a name="testing"/><h3>Testing A Python Report Definitions</h3>
<p>If the following script fragment (with the appropriate name of the report class replacing 'my_task_report') is appended to the python file the script can be run from a Python prompt.<p>
<pre>
def test(xmlFile=None,jobId=None,reportFile=None):
  import sys,os
  if reportFile is None:
    if xmlFile is not None:
      reportFile = os.path.join(os.path.split(xmlFile)[0],'report.html')
    else:
      reportFile = os.path.join(os.getcwd(),'report.html')
  r = my_task_report(xmlFile=xmlFile,jobId=jobId)
  r.as_html_file(reportFile)
  if len(r.errorReport())>0: print 'ERRORS:',r.errorReport()
</pre>
<p>It is easiest to test if you have previously run the task from the gui so that there is program output xml and a jobId that can be input to the test. The command line is:</p>
<pre>
> CCCP4I2_TOP/bin/pyi2

>>>  import my_task_module
>>>  my_task_module.test(my_xmlfile,my_jobid)
</pre>
<p>The xml file should be the output xml from a job run previously and the jobId (not the same as the job number which is displayed in the project viewer)  can be found in the meta-data header of files such as <i>params.xml</i> and <i>input_params.xml</i>).  This will create report called <i>report.html</i> in the working directory.</p>
<p>Alternatively to test run the report parser in the GUI where you can see the result better: after running an appropriate job once, close the GUI while it is displaying the report for the job, delete the report.html file for that job and reopen the GUI; it should recreate and display the report.</p>
<p>A good current working example is in tasks/buccaneer_build_refine/buccaneer_build_refine_report.py</p>
<p>Note that in the <i>test()</i> method above the <i>Report.errorReport()</i> method is used to return a <a href="./error_handling.html">CErrorReport</a> which is a list of errors and warnings recorded for the Report and its child objects. If this has non-zero length then it is printed out.</p>

<a name="appendix a"/><h3>Appendix A - The Database data accessible in the jobInfo dictionary</h3>
<pre>
filenames / XYZIN
          / HKLIN
          / XYZOUT
          / HKLOUT
          etc
runtime
status
taskname
jobid
jobnumber
projectid
projectname
tasktitle
fileroot - the job directory
descendentjobs - a list of jobIds
</pre>

<a name="appendix b"/><h3>Appendix B - The CCP4mg scene file</h3>
<p>NB this will only work with recent nightly build versions of CCP4mg (post 16th Oct 2012).</p>
<p>A simple example of scene template:</p>
<pre>
&lt;scene>
  &lt;data>
    &lt;MolData id='id1'>
       &lt;filename database="filenames/XYZOUT"/>
    &lt;/MolData>
  &lt;/data>
  &lt;wizard>&lt;template>ribbons:colour chains&lt;/template>
    &lt;parameters>
      &lt;MolData1>id1&lt;/MolData1>
    &lt;/parameters>
  &lt;/wizard>
&lt;/scene>
</pre>
<p>This template requires only one piece of substituted data - the <i>XYZOUT</i> file from the <i>database</i> is substituted as the filename for the <i>&lt;MolData>&lt;filename></i> element to give the scene file:</p>
<pre>
<ccp4:ccp4i2 xmlns:ccp4="http://www.ccp4.ac.uk/ccp4ns">
  &lt;ccp4i2_header>
    &lt;function>MGSCENE&lt;/function>
    &lt;projectName>s12&lt;/projectName>
    &lt;userId>lizp&lt;/userId>
    &lt;ccp4iVersion>0.0.1&lt;/ccp4iVersion>
    &lt;jobId>66b40dd7146111e2875a3c0754185dfb&lt;/jobId>
    &lt;projectId>969cdfae138111e2acd83c0754185dfb&lt;/projectId>
    &lt;creationTime>14:39 12/Oct/12&lt;/creationTime>
    &lt;jobNumber>4&lt;/jobNumber>
  &lt;/ccp4i2_header>
  &lt;ccp4i2_body>
    &lt;scene>
      &lt;data>
       &lt;MolData id="id1">
         &lt;filename>/Users/lizp/Desktop/test_projects/s12/CCP4_JOBS/job_4/XYZOUT.pdb&lt;/filename>
       &lt;/MolData>
      &lt;/data>
      &lt;wizard>
        &lt;template>ribbons:colour chains&lt;/template>
        &lt;parameters>
          &lt;MolData1>id1&lt;/MolData1>
        &lt;/parameters>
      &lt;/wizard>
   &lt;/scene>
  &lt;/ccp4i2_body>
&lt;/ccp4:ccp4i2>
</pre>
<p>This file has the standard CCP4i2 xml structure with a header containing metadata describing the provenance of the file. The body of the file is one or more <i>&lt;scene></i> elements. Each <i>&lt;scene></i> element contains a &lt;data> block that specifies the files to be loaded and a <i>&lt;wizard></i> block that specifies how the data should be drawn using a CCP4mg wizard template.</p>
<p>The  &lt;data> block should list the files to be loaded as <i>&lt;MolData></i> or <i>&lt;MapData></i> elements. These elements must have unique id attributes and a <i>&lt;filename></i> sub-element. Usually the actually filename will need to be substituted in from the filenames in the CCP4i2 database so the <i>database</i> attribute should be used to specify the source of the filename.</p>
<p>The  <i>&lt;wizard></i> element should contain a <i>&lt;template></i> sub-element that specifies the CCP4mg wizard template in the form <i>folder:template name</i>. A template can be selected from the existing wizard templates which can be viewed in CCP4mg or something appropriate can be created (see ccp4mg/help/picture_wizard.html and talk to Liz or Stuart).  Picture wizard templates are partially a Python script which can apply some intelligence in setting up a display but they can also have some options which can be set. The options are in the <i>CHOICES</i> section of the wizard template file. The   <i>&lt;wizard></i> sub-element  <i>&lt;parameters></i> should contain sub-elements specifying values for the wizard 'choices' and particularly should provide values for <i>MolData</i> and <i>MapData</i> parameters which cross-reference to the <i>id</i> attributes of the sub-elements of the <i>&lt;data></i> section. Note that although the wizard is mostly used in CCP4mg to setup the display of a single coordinate file it can also be used to specify the display of map objects and of multiple data objects.</p>
<p>There is an alternative mechanism to specify a simple scene that does not use the wizard, for example:</p>
<pre>
&lt;scene>
  &lt;data>
    &lt;MolData id='id1'>
       &lt;filename database="filenames/XYZOUT"/>
       &lt;MolDisp>
        &lt;select>peptide&lt;/select>
        &lt;colour>bychain&lt;/colour>
        &lt;style>CYLINDERS&lt;/style>
       &lt;/MolDisp>
    &lt;/MolData>
    &lt;MapData id='id2'>
      &lt;filename database="filenames/HKLOUT"/>
      &lt;columns> &lt;F>2FOFCWT &lt;/F> &lt;PHI>PH2FOFCWT &lt;/PHI> &lt;/columns>
      &lt;difColumns> &lt;F>FOFCWT &lt;/F> &lt;PHI>PHFOFCWT &lt;/PHI> &lt;/difColumns>
      &lt;model>id1 &lt;/model>
      &lt;gridSize>0.5 &lt;/gridSize>
      &lt;contourUnits>sigma &lt;/contourUnits>
      &lt;MapDisp>
        &lt;contourLevel>3 &lt;/contourLevel>
        &lt;difference>1 &lt;/difference>
      &lt;/MapDisp>
     &lt;/MapData>
  &lt;/data>
&lt;/scene>
</pre>
<p>The <i>MolData</i> element can have one or more <i>MolDisp</i> sub-elements. Each <i>MolDisp</i> element should contain <i>select</i>, <i>colour</i> and <i>style</i> elements and can contain much more such as control of labels, visibility, flashing - see the CCP4mg documentation. (????).  Note that a <i>select</i> attribute could be added to any of the elements so their values can be taken from the program output.<p>
<p>Any of the aspects of CCP4mg presentation that can be controlled using the CCP4mg XML format can also be incorporated in the scene file. Probably the most useful feature is control of the view using:</p>
<pre>
   &lt;View>
      &lt;centre_MolData>id2 &lt;/centre_MolData>
      &lt;centre_selection>A/1170(DUP) &lt;/centre_selection>
      &lt;orientation_auto> &lt;molData>id2 &lt;/molData> &lt;selection>A/1170(DUP) &lt;/selection> &lt;/orientation_auto>
      &lt;scale_auto>1 &lt;/scale_auto>
   &lt;/View>
</pre>
<p>Here the <i>MolData</i> object and (optionally) an atom selection that will be the centre of the view are specified. The <i>orientation_auto</i> element then tells CCP4mg to try to find the best orientation to show a specified atom selection. <i>scale_auto</i> is a flag to CCP4mg to scale to zoom of the specified atom selelction rather than show all visible atoms.</p>

<p>Alternatively the scale,orientation and centring can be specified explicitly. In this example variously other display parameters are set - these could also be used the the 'auto' view parameters shown above.</p>
<pre>      
   &lt;View>
     &lt;scale>58.0125</scale>
     &lt;orientation>
       &lt;q0>0.0134139428983 &lt/q0>
       &lt;q1>0.336496398576 &lt/q1>
       &lt;q2>-0.507403789037 &lt/q2>
       &lt;q3>-0.793178186004/q3>
    &lt;/orientation>
    &lt;centre_xyz>
      &lt;x>-23.676&lt;/x>
      &lt;y>8.538&lt;/y>
      &lt;z>5.262&lt;/z>
    &lt;/centre_xyz>
    &lt;fog_enabled>1&lt;/fog_enabled>
    &lt;fog_near>-1.1&lt;/fog_near>
    &lt;fog_far>26.01&lt;/fog_far>
    &lt;slab_offset>27.5&lt;/slab_offset>
    &lt;slab_enabled>false&lt;/slab_enabled>
    &lt;slab_width>55.0&lt;/slab_width>
  &lt;/View>
</pre>
<p>Note that it is possible to have more than one <i>scene</i> specified in the file.  It is intended that CCP4mg will use these either to create multiple pictures in one program run or, if it is opened in interactive mode, to create a Presentation which gives the user a choice of views.</p>

<a name="appendix c"/><h3>Appendix C - Style Guide</h3>

<p>Firstly the 'running' reports that are updated in real time usually consist of a graph that shows, for example, progress per cycle and possibly a table showing initial, previous and current cycle values.</p>
<p>Final reports should begin with a short text summary of what the task achieved, any issues and warning messages in red.  The terminology here (and throughout the report) should be consistent with the terminology used in the gui and documentation.  Links to documentation are encouraged.</p>
<p>There is usually an open folder showing a graphical summary of the task followed by closed folders with more detailed information possibly from the separate steps of the task.</p>


<p>Visual presentation (i.e. graphs) is preferred over tables - thought tables presenting the same information may be good. The usual good practice for graphs - label axes, legends etc. apply. A simple clear graph or multiple simple clear graphs are preferred over over-loaded graphs (though beware what users might want to look at simultaneously.) </p>


<address></address>
<!-- hhmts start -->Last modified: Tue Jun  2 12:32:24 BST 2015 <!-- hhmts end -->
</body> </html>
