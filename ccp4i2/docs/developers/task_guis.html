<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>CCP4I2 Developers: Writing Task GUIs</title>
</head>

<body>
<h1>CCP4I2 Developers: Writing Task GUIs</h1>

<a href="#introduction">Introduction</a>
<br/><a href="#folders">Folders/tabs</a>
<br/><a href="#CTaskWidget">CTaskWidget class overview</a>
<br/><a href="#createLine">createLine() definition keywords</a>
<br/><a href="#toggle">toggle and toggleFunction arguments</a>
<br/><a href="#accessing_widgets">Accessing individual widgets</a>
<br/><a href="#widget_qualifiers">Widget Qualifers</a>
<br/><a href="#signals_and_slots">Using the Qt Signals and Slots</a>
<br/><a href="#data_analysis">Data analysis in the task gui</a>
<br/><a href="#setQualifiers">Changing parameter qualifiers</a>
<br/><a href="#autogenerating_guis">Auto-generating GUIs</a>
<br/><a href="#multiple_task_guis">Multiple Task Interfaces to One Wrapper</a>
<br/><a href="#taskmenu">The Task Menu</a>
<br/><a href="#popout_tasks">Creating Child Pop-out Task GUI</a>
<br/><a href="#speedup">Speeding drawing of tasks</a>


<a name="introduction"><h3>Introduction</h3>
<p>Please read the <a href="./data_classes.html">Data Classes<a> documentation first.</p>
<p>If you have implemented a wrapper or pipeline in the ccp4i2 wrappers or pipelines directories then a basic gui can be autogenerated from the def file and will be accessible from the 'Wrappers' section at the bottom of the list of jobs. Note that if the wrapper uses some data object that does not have a corresponding widget implelemented then that data will not appear in the gui and you need to ask Liz to fix that. To create a better gui you need to implement a Python script called tasks/mytask/CTaskmytask.py as a subclass of CTaskWidget from qtgui/CCP4TaskWidget. See < a href="../../tasks/buccaneer_build_refine/CTaskbuccaneer_build_refine.py">tasks/buccaneer_build_refine/CTaskbuccaneer_build_refine.py</a> for an example.Also look at < a href="../../tasks/demo/CTaskdemo.py">tasks/demo/CTaskdemo.py</a> does not interface to any real wrapper but is used to test and demo gui features.</p>
<p>Note that if there is an error in the Python file which prevents it being imported when CCP4i2 starts then this is reported to the terminal and the <i>Program print log</i> (under <i>Utilities</i> pull-down menu) and the task will not appear on the task menu.  Any other errors will be reported to the same places when you try to open the task widget.</p>
<a name="folders"><h3>Folders/Tabs</h3>
<p> The task gui is split into 'folders' or 'tabs'; these two modes depend on the option under <i>Preferences</i> but do not require any alternative coding by the application programmer. The top folder is <i>Input Data</i> which should contain all of the required input files or data. Ideally a user should be able to run the program without looking at any other folder. There are currently a couple of features in the <i>Input Data</i> folder that are added by the core system:</p>
<ul>
<li>an option to set the job title</li>
<li>a 'follow from' option to choose a previous job whose ouput data will be input to this job</li>
</ul>
<p>The 'follow from' features should be switched off ( CTaskWidget.AUTOPOPULATEINPUT = False ) if the the task is only importing data.
Note that the application should not have any <i>jobTitle</i> parameter that would be redundant with the <i>jobTitle</i> parameter handled by the core. The parameters managed by the core are recorded in the task container in a sub-container named <i>guiParams</i> and appear at the bottom of the params files.</p>
<p>The 'follow from' feature is implemented by the core system but,
for the appropriate input files, the qualifier <i>fromPreviousJob</i>
must be set <i>True</i>. There is no 'Output Data' folder - the output
file names are set automatically and the user can 'export' files after
the job has completed. Also there is no 'Protocol' folder (as ther was
in CCP4i) so some options that may have gone in the 'Protocol' folder
may now be in the 'Input data' folder. There is usually an
<i>Options</i> folder for basic options and then there may be one of
more specific advanced options folders.</p>
<p>Note that the initial opening of a complex task in the gui can take
significant time and a way to speed this up is to only draw the
'hidden' task frames when the user opens them - see <a
href="#speedup">speedup</a> below.</p>

<a name="CTaskWidget"><h3>CTaskWidget class overview</h3>
<p>Minimal code to create a new task widget:</p>
<pre>
from qtgui import CCP4TaskWidget
class CTaskBuccaneer(CCP4TaskWidget.CTaskWidget):
  TASKNAME = 'buccaneer'
  TASKVERSION = 0.0
  TASKMODULE='model_building'
  TASKTITLE='Buccaneer automated model building'
  SHORTTASKTITLE='Buccaneer'
  WHATNEXT = ['coot_rebuild','refmac_martin','buccaneer_build_refine']
  MGDISPLAYFILES = ['XYZOUT']
  DESCRIPTION = '''Do several cycles of alternate model building with Buccaneer and refinement with Refmac'''
  
  def __init__(self,parent):
    CCP4TaskWidget.CTaskWidget.__init__(self,parent)

  def drawContents(self):
    pass
</pre>

<p>The essential attributes for the sub-class
<ul>
<li>TASKNAME - the task name that should be the same as the TASKNAME in the corresponding wrapper</li>
<li>TASKVERSION - the versioning is not currently used but should correspond to the wrapper version How should it map to CCP4 and program versions??</li>
<li>TASKMODULE - the catagory that the task appears in on the gui task menu.  Must be one of those listed in <i>MODULE_ORDER</i> in <i>qtcore/CCP4TaskManager.py</i>. The <i>wrapper</i> and <i>test</i> modules will not appear in a release version of the program.</li>
<li>TASKTITLE - title to appear in the gui task menu.</li>
<li>SHORTTASKTITLE - short title to appear in the gui where brevity necessary e.g. 'What next'and JobList .</li>
<li>DESCRIPTION - a longer description to appear as a tooltip in the gui task menu.</li>
<li>MGDISPLAYFILES - a list of the parameters containing the names of files to be displayed in molecular graphics for this job</li>
<li>WHATNEXT - a list of tasks that may follow after this task (or implement <i>whatNext()</i> function - see below).</li>
<li>PROGRAMHELP - a list of program help files found as $CCP4/html/xxxx.html to be listed under Help button</li>
</ul>
<p>Other possible attributes:</p>
<ul>
<li>CLONEABLE - Boolean flag if the task can be cloned - default is True</li>
<li>EDITOR - is the task solely for data input (default False). If True the gui is modified to give a 'Save' button rather than a 'Run' button.</li>
<li>AUTOPOPULATEINPUT - can the inputs to this task be auto-populated from a previous task (default True)</li>
</ul>

<p>The <i>drawContents()</i> method should specify the layout of the gui using the library of methods documented below.</p>
<table border="1">
  <tr><th>CTaskWidget method</th><th>Argument</th><th>Description</th></tr>
     
   <tr><td>openFolder</td><td colspan="2">Start definition of a tab or folder</td></tr>
   <tr><td></td><td>folderFunction</td><td>Default is 'general' - should be 'inputData' for first folder</td></tr>
   <tr><td></td><td>title</td><td>A short title to appear on folder tab or title bar</td></tr>
   <tr><td></td><td>toggle</td><td>A list of parameters for controlling visibility of the folder - <a href="#toggle">see below</a></td></tr>
   <tr><td></td><td>toggleFunction</td><td>A list of parameters for controlling visibility of the folder - <a href="#toggle">see below</a></td></tr>
   
   <tr><td>closeFolder</td><td colspan="2">End definition of a tab or folder</td></tr>

   <tr><td>createLine</td><td colspan="2">Define content on one line of the gui - returns a Qt QFrame</td></tr>
   <tr><td></td><td>defintion</td><td>list of strings that are keywords and parameters to define line content (<a href="#createLine">see below</a>)</td></tr>
   <tr><td></td><td>toggle</td><td>A list of parameters for controlling visibility of the line - <a href="#toggle">see below</a></td></tr>
   <tr><td></td><td>toggleFunction</td><td>A list of parameters for controlling visibility of the line - <a href="#toggle">see below</a></td></tr>
   <tr><td></td><td>appendLine</td><td>A preceeding line (as returned by <i>createLine()</i>) to which this 'line' is appended</td></tr>
   
   <tr><td>openSubFrame</td><td colspan="2">Start definition of lines that are grouped for purpose of toggling visibility or creating a frame. Returns a Qt QFrame.</td></tr>
   <tr><td></td><td>frame</td><td>default False - if true draw a frame around the sub-frame</td></tr>
   <tr><td></td><td>toggle</td><td> A list of parameters for controlling visibility of the sub-frame - <a href="#toggle">see below</a> </td></tr>
   <tr><td></td><td>toggleFunction</td><td>A list of parameters for controlling visibility of the folder - <a href="#toggle">see below</a></td></tr>
   
   <tr><td>closeSubFrame</td><td colspan="2">End definition of group pf lines</td></tr>
   
   
   <tr><td>openStack</td><td colspan="2">Open definition of a stack of two or more lines of which only one will be displayed</td></tr>
   <tr><td></td><td>controlVar</td><td>Name of variable controlling which line in the stack is visible. This variable is probable presented as radio buttons in the preceeding line of the gui.</td></tr>
   
   <tr><td>closeStack</td><td colspan="2">End definition of a stack</td></tr>
    
   <tr><td>createRadioGroup</td><td colspan="2">Create set of radio buttons aranged one per line</td></tr>
   <tr><td></td><td>label</td><td>A string label</td></tr>
   <tr><td></td><td>itemList</td><td>A list of string labels for each radio button</td></tr>
   <tr><td></td><td>objectName</td><td>The name of the parameter that is controlled by the radio buttons - expected to have <i>enumerators</i> qualifer that is list same length as <i>itemList</i></td></tr>

   <tr><td>setHelpFile</td><td colspan="2">Name of help file linked to by all widgets defined after a call to this method</td></tr>
   <tr><td></td><td>helpFile</td><td>The name of a file that is expected to be found in $CCP4_TOP/docs/tasks</td></tr>
   <tr><td>whatNext</td><td colspan="2">This is a module level function that returns a list of suggested next tasks.</td></tr>
   <tr><td></td><td>jobId</td><td>The id of a finished job that is an instance of this task</td></tr>
   <tr><td></td><td> </td><td> </td></tr>
   
   <!--
   <tr><td> </td><td colspan="2"> </td></tr>
   <tr><td></td><td> </td><td> </td></tr>
   <tr><td></td><td> </td><td> </td></tr>
   -->
 </table>
 <p>The following methods may be needed to define some more dynamic behaviour.</p>
<table border="1">
  <tr><th>CTaskWidget method</th><th>Argument</th><th>Description</th></tr>
 
   <tr><td>visibleFolder</td><td colspan="2">Return the index of the curently visible 'folder' - only relevant in tab mode.</td></tr>
   
   <tr><td>setVisibleFolder</td><td colspan="2">Set which 'folder' is visible (only relevant in tab mode)</td></tr>
   <tr><td></td><td>title</td><td>title of 'folder'</td></tr>
   <tr><td></td><td>index</td><td>index of folder (only one of these arments should be used)</td></tr>
   <tr><td></td><td>  </td><td>  </td></tr>
   <tr><td></td><td>  </td><td>  </td></tr>
   
   <tr><td>getContainer</td><td colspan="2">Return the instance of <i>CContainer</i> which holds the task parameters</td></tr>
   
   <tr><td>getWidget</td><td colspan="2">Return the widget for the named parameter</td></tr>
   <tr><td></td><td>name</td><td>Parameter name</td></tr>
   
   <tr><td>project</td><td colspan="2">Return the name of the project of the job open in the task window</td></tr>
  
   <tr><td>jobId</td><td colspan="2">Return the id of the job (an integer) of the job open in the task window</td></tr>
     
   <tr><td>getParams</td><td colspan="2">Return python dict of values of parameters currently set in the gui </td></tr>
   <tr><td></td><td>paramsValues</td><td>A Python dict whose keys are the names of the parameters whose values are required.</td></tr>
  
   <tr><td>setParams</td><td colspan="2">Set gui widget values to reflect the input parameters</td></tr>
   <tr><td></td><td>paramsValues</td><td> A Python dict of values to be set in the gui</td></tr>
   
   <tr><td>updateViewFromModel</td><td colspan="2">refresh the gui from the parameters in the task container</td></tr>
   
   <tr><td>validate</td><td colspan="2">validate and mark any invalid parameters in the gui</td></tr>
   
   <tr><td>isValid</td><td colspan="2">Return a list of any invalid parameters in the gui</td></tr>

   <tr><td>createWidget</td><td colspan="2">Return an instance of the appropriate widget for a named parameter in the task container</td></tr>
   <tr><td></td><td>name</td><td>Parameter name</td></tr>
   <tr><td></td><td>widgetQualifiers</td><td>a Python dict of qualifying parameters for the widget</td></tr>
   
</table>   


<a name="createLine"><h3>createLine() definition keywords</h3>
<p>The <i>definition</i> argument to <i>createLine()</i> is a list of strings which consist of keywords followed by a fixed number of arguments. Note that a 'line' may be a very fat line containing a complex widget - in this case there should probably be no other labels or widgets specified in the line.</p>
<table border="1">
  <tr><th>keyword</th><th>Argument</th><th>Description</th></tr>

   <tr><td>help</td><td colspan="2">A help link applied to all following widgets in the line</td></tr>
   <tr><td></td><td>target</td><td>The target part of the link - complements the file specified by <i>setHelpFile()</i></td></tr>

   <tr><td>tip</td><td colspan="2">Tooltip to apply to all following widgets in the line</td></tr>
   <tr><td></td><td>tip</td><td>A short text string</td></tr>

   <tr><td>message</td><td colspan="2">Alternative keyword for 'tip'</td></tr>

   <tr><td>label</td><td colspan="2">A text label to appear in the line. Can be styled using HTML tags.</td></tr>
   <tr><td></td><td>label</td><td>a text string</td></tr>
   
   <tr><td>advice</td><td colspan="2">A text label to appear in italics in the line. Can be styled using HTML tags. There should not be anything else in the line</td></tr>
   <tr><td></td><td>label</td><td>a text string</td></tr>

   <tr><td>subtitle</td><td colspan="2">A differently-coloured label that can be used to define sections. Adds a vertical spacer before it and shows a tooltip that should be used to explainthe forthcoming section. Can be styled using HTML tags. There should not be anything else in the line</td></tr>
   <tr><td></td><td>label</td><td>a text string for the label</td></tr>
   <tr><td></td><td>tooltip</td><td>a text string for the tooltip</td></tr>

   <tr><td>spacing</td><td colspan="2">Add a non-stretchable space</td></tr>
   <tr><td></td><td>spacing</td><td>Number of pixels</td></tr>

   <tr><td>stretch</td><td colspan="2">Add stretchable space (usually end of line)</td></tr>
   <tr><td></td><td>stretch factor</td><td>integer (default =1 for widgets and labels) larger value means more stretchable</td></tr>

   <tr><td>widget</td><td colspan="2">Add widget to the line</td></tr>
   <tr><td></td><td><i>-qualifier</i></td><td>Note '-' first character. Qualifier passed as argument to the widget initialisation method</td></tr>
   <tr><td></td><td>name</td><td>Name of parameter</td></tr>   
</table>
   
<a name="toggle"><h3>toggle and toggleFunction arguments</h3>
<p>These are arguments to <i>createLine()</i>, <i>openFolder()</i> and <i>openSubFrame()</i> control whether the line or frame is visible. The visibility is usually dependent on a parameter in the task container (for the <i>toggle</i> argument) or, more complex cases (handled by <i>toggleFunction</i>> have a dependency on multiple parameters and require a function to be implemented to evaluate and return a logical value. If controlling the gui appearance requires the definition of some parameters that are not subsequently used in program wrappers then they should be put in the <i>guiParameters</i> container in the task definition file.</p>
<p>The <i>toggle</i> argument is a list of 3 parameters:</p>
<ul>
<li> <i>parameter</i> - the name of a parameter in the task container</li>
<li> <i>state</i> - the state of the line or folder i.e. 'open' or 'closed' if the parameter has the values..</li>
<li> <i>values</i> - a list of values - default is [True] </li>
</ul>

<p>The <i>toggleFunction</i> argument is a list of 2 parameters:</p>
<ul>
<li> <i>function</i> - a method returning True if the line should be visible</li>
<li> <i>dependencies</i> - parameters on which the visibility is dependent - it will be updated if any of these parameters change</li>
</ul>

<a name="accessing_widgets"><h3>Accessing individual widgets</h3>
<p>It is sometimes necessary to access the individual widgets defined by <i>createLine()</i> - this can be done by callying <i>getWidget(name)</i> where <i>name</i> is the name of the paramter.  This returns a Qt widget that can be customised using the standard Qt methods for that widget type (see the Qt documentation). </p>


<a name="widget_qualifiers"><h3>Widget Qualifers</h3>

<p>These are arguments to <i>createLine()</i> that are inserted after the keyword <i>widget</i> and before the name of the parameter that the widget will represent. For each qualifier the name of the qualifier and the qualifier value are inserted in the argument list - for example:</p>
<pre>
      self.createLine( [ 'widget', '-browseDb', True, 'ABCD' ] )
</pre>
<p>The most common qualifiers are:</p>

<table border="1">

  <tr><th>Qualifier</th><th>Widget for data type</th><th>Description</th></tr>
  <tr><td>-guiLabel</td><td>CDataFile</td><td>A short text label to appear on the widget</td></tr>
  <tr><td>-browseDb</td><td>CDataFile</td><td>A boolean value. Control display of icon to browse the database for files.</td></tr>
  <tr><td>-guiMode</td><td>CString,CInt,CFloat which have enumerator </td><td>Values 'radio','multiLineRadio' or 'combo' determine presentation of alternative parameter values</td></tr>
  <tr><td>-title</td><td>CList</td><td>A short title to appear at top of a list/tree widget</td></tr>
</table>

<a name="signals_and_slots"><h3>Using the Qt Signals and Slots</h3>
<p>The main reason to use signals and slots is to cause some code to be run when the user provides some input. An example of such code might be resetting defaults dependent on the user's choice of input file. Qt signals and slots are explained in detail <a href="http://qt-project.org/doc/qt-4.8/signalsandslots.html">here</a> but you only need to know that any Qt object (and, in the context of the gui, both the data objects and the widgets are Qt objects) emits a signal when something happens (e.g. a button is clicked or the value of a data object is changed). Other objects can 'connect' to the signal i.e. request that whenever a particular signal is emited by a  particular object then a particular function is run. The most relevant signal in CCP4i2 is the <i>dataChanged</i> signal from any data object whenever it is changed.</p>

<p>The code that you require to run on receiving a signal must be a separate function, almost certainly a method of your <i>CTaskWidget</i> subclass.  The request to call that function is via the <i>connect()</i> method and should probably go at the end of task widget <i>drawContents()</i> method. For example to call the <i>analyseXyzin()</i> method every time the <i>XYZIN</i> parameter is changed:</p>

<pre>
  from PyQt4 import QtCore

  ...
  def drawContents(self):
    self.createLine( [  'label','Input model ','widget','XYZIN' ] )

    ...

    self.connect(self.container.inputData.XYZIN,QtCore.SIGNAL('dataChanged'),self.analyseXyzin)
    self.analyseXyzin()

  def analyseXyzin(self):
    if not self.container.inputData.XYZIN.isSet() or not self.container.inputData.XYZIN.exists(): return
    ...
</pre>

<p>Beware that the <i>dataChanged</i> signal is also emited when the
parameter has been unset so you need to test carefully (as in the
example above) that the value is valid and may need to unset defaults
(or whatever your function does).  Beware also that you may need to
call your function explicitly once when you draw the gui to get things
setup initially with whatever data is initially set.</p>
<p>Note that there is an alternative to calling <i>connect</i> - instead
use <i>CPluginScript.connectDataChanged()</i> :
<pre>
    self.connectDataChanged('XYZIN',self.analyseXyzin)
</pre>
<p>which is simpler but only applies to <i>dataChanged</i> signals.</p>

<p>Text input widgets can be tricky because the <i>dataChanged</i> signal will be emitted for every character that the user types and the unfinished input is probably invalid.  An alternative approach for text input is to use the <i>editingFinished()</i> signal from the actual text input widget - this is emitted when th user clicks return or moves the focus out of the widget so suggesting that the input is complete. An example of this calling <i>setDefaultParameters()</i> every time the user finishes editing the <i>TEXT</i> parameter:</p>

<pre>
  def  drawContents(self):
    self.createLine( [  'label','Input some text ','widget','TEXT' ] )

    '''
    self.connect( self.getWidget('TEXT').widget, QtCore.SIGNAL('editingFinished()'), self.setDefaultParameters )


  def setDefaultParameters(self):
    ....
</pre>
<p>The <i>getWidget()</i> method is used to get the widget for the
    <i>TEXT</i> parameter but note that the actual object connected to
    is the member <i>widget</i>.  Also note the brackets that are
essential in the <i>editingFinished()</i> signal definition.<p>


<a name="data_analysis"><h3>Data analysis in the task gui</h3>
<p>The gui code may need to do significant analysis in order to check
for appropriate input or set appropriate default parameters
etc.. There is an example of this in the <a
href="../../wrappers/matthews/script/matthews.py">Matthews task</a>
where the results of an analysis are presented in a text widget.</p>
<p>It is possible to use wrapper scripts from the gui as demonstrated
in the <a
href="../../pipelines/crank2/script/CtaskCrank2.py">Crank2 task</a>.
The significant code there is:
<pre>
  from core import CCP4Modules,CCP4PluginScript
  try:
    workDir = CCP4Modules.PROJECTSMANAGER().jobDirectory(self.jobId(),subDir='TMP')
  except:
    workDir = None
  try:
    defaults = CCP4PluginScript.CPluginScript(dummy=True,workDirectory=workDir).makePluginObject(pluginName='crank2',reportToDatabase=False).process(self.container)
  except:
    pass
</pre>
<p>First this code calls <i>PROJECTSMANAGER().jobDirectory()</i> to
get the path of the <i>TMP</i> sub-directory of the appropriate job
directory so all files will be written here. (The <i>TMP</i>
sub-directory  may be deleted later by <a href='./pipelines.html#temp'>Cleanup</a>.)Then an instance of the
<i>CPluginScript</i> base class is created and the
<i>makePluginObject()</i> method used to create an instance of the
required 'crank2' wrapper. The <i>CPluginScript</i> is instantiated
with <i>dummy=True</i> that prevents jobs and files being recorded in
the database and the <i>workDirectory</i> is set to the <i>TMP</i>
sub-directory. Sub-tasks of this instance of <i>CPluginScript</i>, such as the <i>crank2</i>
plugin, are then given job-directories in the <i>TMP</i>
directory. The <i>crank2.process()</i> method has an optional
<i>container</i> argument that is passed the current gui container
with the current state of the gui that can be queried by the
<i>crank2.process()</i> method.</p>
  

<a name="setQualifiers"><h3>Validation and changing parameter qualifiers</h3>
<p>The validation of gui input to highlight missing/invalid input and to check before running a job is done by the widget's <i>validate()</i> method. The particular requirements for each data object are specified by qualifiers of the object that are usually defined in the <i>def</i> file.  The requirements for some parameter may be dependent on other parameters such that its qualifiers mat need changing by using the <i>CData.setQualifiers()</i> method. There is an example of this in the <i>dumMee</i> demo task ( <a href="../../tasks/dummy/CTaskDummy.py">tasks/dummy/CTaskDummy.py</a> can be seen if the <i>Demo</i> folders on the <a href="#taskmenu">task menu</a> are open). The behaviour of the PDBIN file parameter is dependent on the PDBIN_COMPULSARY boolean parameter.
 <pre>
    self.createLine ( [ 'widget' , 'PDBIN_COMPULSARY' , 'label' ,'Model data input is compulsary'])
    self.createLine ( [ 'widget','PDBIN' ] )

    self.connectDataChanged('PDBIN_COMPULSARY',self.handlePDBIN_COMPULSARY)
    self.handlePDBIN_COMPULSARY()
</pre>
<p>Here the two widgets for <i>PDBIN_COMPULSARY</i> and <i>PDBIN</i>
    are drawn and then a <i>connectDataChanged</i> call ensures that
    <i>handlePDBIN_COMPULSARY()</i> is called whenever
    <i>PDBIN_COMPULSARY</i> is changed. There is also an call to
    <i>handlePDBIN_COMPULSARY()</i> to initialise the status
    correctly. The code in  <i>handlePDBIN_COMPULSARY()</i> checks the
    state of <i>PDBIN_COMPULSARY</i> and sets the
    <i>allowUndefined</i> qualifier of <i>PDBIN</i> appropriately.  There is also a call to the <i>validate()</i> method of the <i>PDBIN</i> widget to ensure the highlightling of the widget is updated.</p>
<pre>
  def handlePDBIN_COMPULSARY(self):
    mode = bool(self.container.inputData.PDBIN_COMPULSARY)
    self.container.inputData.PDBIN.setQualifiers({'allowUndefined' : (not mode) } )
    self.getWidget('PDBIN').validate()
</pre>
<p>The behaviour seen in the gui is that if the
    <i>PDBIN_COMPULSARY</i> checkbox is checked but there is no valid
    file selected in the <i>PDBIN</i> widget then that widget is
highlighted.</p>

<p>When the user clicks the <i>Run</i> button the input is validated
    and if the validation fails there is an error report and the job
    run is aborted. By default the tests are the same validation
    checks of individual widgets that lead to widgets being
    highlighted in red. If the task requires additional tests, perhaps
    cross-checking two or more separate widgets, then you
    should implement a <i>CTaskWidget.taskValidation()</i> method
that returns a <i>CErrorReport</i>. There is an example of this at the
    bottom of 
    <i>dumMee</i> demo task ( <a
    href="../../tasks/dummy/CTaskDummy.py">tasks/dummy/CTaskDummy.py</a>
    can be seen if the <i>Demo</i> folders on the <a
    href="#taskmenu">task menu</a> are open). The example tests if the
    space group in PDB and MTZ file are the same and returns an error
    if they are not.
</p>

<a name="autogenerating_guis"><h3>Auto-generating GUIs</h3>
<p>This is a work-in-progress (June 2014) being developed particularly for generating a gui for MR Phaser. Other interfaces might require additional features - please contact Liz.</p>
<p>'Autogenerating' means creating a GUI from the information in the
def file without any Python coding. When CCP4i2 is run in DEVELOPER
mode it will autogenerate guis from def files for any wrappers which
do not have a specified gui. The same mechanism, generating gui
elements from information in the def file, can be used for some parts
of a gui, this is probably most useful for the more obscure (and
perhaps more changeable) control parameters. We expect that most
control parameters are simple data types (booleans,floats etc) that
have widgets defined in CCP4i2 - more complex data types might need
custom written widgets and guis. An example of including some
autogenerated gui is in the <i>drawContents()</i> method of
<i>dumMee</i> demo task ( <a
href="../../tasks/dummy/CTaskDummy.py">tasks/dummy/CTaskDummy.py</a>
can be seen if the <i>Demo</i> folders on the <a href="#taskmenu">task
menu</a> are open). The <i>Autogenerated</i> folder is generated by the code:</p>
<pre>
 self.openFolder(title='Autogenerated')
 self.autoGenerate(container=self.container.controlParameters,selection={'includeParameters' : ['OBSCURE_MODE','OBSCURE_CUTOFF']})
</pre>
<p>After opening a folder the <i>autoGenerate()</i> method is called
with the arguments: <i>container</i> that is the def file container
that is the source of specifications of parameters and
<i>selection</i> that is a Python dict with several possible keys that
specify which parameters in the container are to be drawn.The
<i>includeParameters</i> item lists parameters to be included in the gui or
<i>excludeParameters</i> lists parameters to be excluded when putting
all other parameters from the container in the gui.</p>

<p/>All data classes have three optional qualifiers that help define presentation in an autogenerated gui:
<br/>
<table border="1">
 <tr><th>Qualifier</th><th>Description</th></tr>
 <tr><td>-guiLabel</td><td>A short text label to appear by the widget</td></tr>
 <tr><td>-toolTip</td><td>A longer text description</td></tr>
 <tr><td>-guiDefinition</td><td>The xml element contains sub-elements that will be converted to a Python dict. There is no restriction on key values but currently used key values are given below</td></tr>
</table>
<br/>
<table border="1">
 <tr><th>guiDefinition keys</th><th>Description</th></tr>
  <tr><td>toggleParameter</td><td>Name of a parameter that controls visibility of the widget in the GUI</td></tr>
  <tr><td>toggleState</td><td>The state (open/closed) for the listed <i>toggleValues</i> (default is open)</td></tr>
  <tr><td>toggleValues</td><td>The values of <i>toggleParameter</i> for which <i>toggleState</i> applies</td></tr>
  <tr><td>expertLevel</td><td>(Or any arbitary name) can be used in the selection argument to <i>autoGenerate()</i></td></tr>
</table>

<p>Related parameters can be grouped into a container and they will then be displayed in a frame probably with a surrounding border. The visiblity of the frame will also be toggleable. The container can have the same qualifiers as listed above for the parameters.</p>

<a name="multiple_task_guis"><h3>Multiple Task Interfaces to One Wrapper</h3>
<p>Some programs provide multiple functionalities that are used to solve different problems at different points in the structure solution process and these are best presented to the user in different task interfaces. To implement this the developer could provide multiple wrappers to the one program but one wrapper will be easier to maintain. Typically the different modes of the program may require different data file inputs and have different defaults. The input data, defaults etc. are set in <i>def.xml</i> files and again, to ease maintenance, it would be better to avoid replication between <i>def.xml</i> files. The solution to this is to have one 'base' <i>def.xml</i> file that specifies all the input, output and control parameters for the wrapper. A 'derived' <i>def.xml</i> file 'includes' the 'base'  <i>def.xml</i> file and then specifies any altered parameter definitions that will overwrite the 'base' definitions.  An example of this is in <a href="../../tasks/molrep_den/molrep_den.def.xml">ccp4i2/tasks/molrep_den/molrep_den.def.xml</a></p>

<pre>
   &lt;ccp4i2_header>
    ...
    ...
    &lt;pluginName>molrep_den&lt;/pluginName>
    &lt;pluginTitle>Fitting to a map using Molrep&lt;/pluginTitle>
    &lt;jobId/>
  &lt;/ccp4i2_header>
  &lt;ccp4i2_body id="molrep_den">
    &lt;file>
      &lt;CI2XmlDataFile>
        &lt;project>CCP4I2_TOP&lt;/project>
        &lt;relPath>wrappers/molrep_mr/script&lt;/relPath>
        &lt;baseName>molrep_mr.def.xml&lt;/baseName>
      &lt;/CI2XmlDataFile>
    &lt;/file>
    &lt;container id="inputData">
       &lt;content id="F_SIGF">
         &lt;className>CObsDataFile &lt;/className>
         &lt;qualifiers>
   ...
   ...
</pre>

<p>Here the <i>molrep_den</i> def file is 'derived' from the <i>molrep_mr</i> def file. The file/CI2XmlDataFile element specifies the file path for a 'base' def.xml file and the rest of this file contains specification of only a few parameters that are different between <i>molrep_den</i> and <i>molrep_mr</i>.</p>
<p>The <i>molrep_den</i> GUI definition in <a href="../../tasks/molrep_den/Cmolrep_den.py">ccp4i2/tasks/molrep_den/Cmolrep_den.py</a> must also contain an additional class parameter <i>GUINAME</i>:

<pre>
class Cmolrep_den(CCP4TaskWidget.CTaskWidget):

  TASKTITLE='Search density using Molrep'
  TASKNAME = 'molrep_mr'
  GUINAME = 'molrep_den'
  TASKMODULE='model_building'
  ...
</pre>
<p>Note that the <i>TASKNAME</i> is the name of the script that this GUI will run and <i>GUINAME</i> is the unique name for this GUI which should matchup with the <i>pluginName</i> in the header of the <i>def.xml</i> file. (In case you are wondering, for most GUIs the <i>GUINAME</i> is assumed to be the same as the <i>TASKNAME</i>.)</p>

<a name="taskmenu"><h3>The Task Menu</h3>
<p>The task menu in the gui is populated automatically at startup by taking information from the <i>CTaskWidget</i> subclasses. The modules presented in the menu are listed at the top of <a href="../../core/CCP4TaskManager.py">ccp4i2/core/CCP4TaskManager.py</a>.  The <i>CTaskWidget</i> class attributes that determine the menu are:</p>
<table border="1">
  <tr><td><b>CTaskWidget Class Attributes</b></td><td><b>Description</b></td></tr>
  <tr><td>TASKNAME</td><td>The obligatory name of the script essential for cross-refererence to other files</td></tr>
  <tr><td>TASKVERSION</td><td>A version number for the script. Please give one!</td></tr>
  <tr><td>TASKMODULE</td><td>Refers to where the task should appear in the task menu, can be list of multiple modules</td></tr>
  <tr><td>TASKTITLE</td><td>The name for the task to appear in the GUI </a></td></tr>
  <tr><td>DESCRIPTION</td><td>More details to appear in the GUI</td></tr>
  </table>
  <p>Note that tasks under developement should be put in the
  <i>wrapper</i> or <i>test</i> module and the developer can make
  these modules visible in the gui by setting the <i>SHOW_WRAPPERS</i>
  parameter at the top of the <i>ccp4i2/core/CCP4TaskManager.py</i>
  file to True. Note that the demo task <i>dumMee</i> is only visible
  if <i>SHOW_WRAPPERS</i> is True.<p>
  <p>The preferred style for title and description can be inferred from the existing menu but:
  <br/>The title should be short - remember it will appear in the left-hand job list as well.  The names of programs should not appear unless really necessary to distinguish similar tasks.
  <br/>The description should amplify on the functionality and include names of key programs run.
  </p>
  <p>The icon on the menu is taken from a file <i>ccp4i2/qticons/</i>TASKNAME<i>.png</i>.These image files should have resolution at least 32x32 and are currently also displayed at 24x24 in the 'Compact' style - see <i>Preferences</i>.</p>

<a name="popout_tasks"><h3>Creating Child Pop-out Task GUI</h3>
<p>This is a facility to put a button in the task window that creates another task gui in a pop-out window. The parent <i>CTaskWidget</i> class should also reimplement the <i>CTaskWidget.handleLaunchedJob()</i> method which is called when the child job is created and when it has finished running. There is an example in <a href="../../tasks/dummy/CTaskDummy.py">tasks/dummy/CTaskDummy.py</a> which creates a launch button for the <i>Gesamt</i> task. The result can be seen in the <i>Create New Job</i> folder of the <i>dumMee</i> task (only visble if the <i>Demo</i> folders on the <a href="#taskmenu">task menu</a> are open). The hypothetical scenario is that the user needs to reposition the input coordinate file by superposing on another model before continuing with this task.  The button to lauch and alternative task is defined by the <i>launchButton</i> keyword input to <i>createLine()</i> and it should be followed by the name of the task to be opened.  In the example code below the <i>XYZIN</i> input widget and the lauch button are drawn. A <i>connect()</i> call is used to ensure that <i>updateLauchButton()</i> is called whenever the value of <i>XYZIN</i> is changed and this is also called immediately in order to disable the launch button if <i>XYZIN</i>  is unset. </p>

  <pre>
    self.createLine(['label','Enter a coordinate file to test launch job button'])
    self.createLine(['widget','XYZIN'])
    self.createLine(['label','Superpose the coordinates on another model by','launchButton','gesamt'])
    # Update the status of the lauch button dependent on selection of XYZIN
    self.connect(self.container.inputData.XYZIN,QtCore.SIGNAL('dataChanged'),self.updateLauchButton)
    # .. and initialise its status
    self.updateLauchButton()
  </pre>

 <p>The code to enable/disable the launch button:</p>

<pre>
  def updateLauchButton(self):
    # Enable the launch button dependent on whether XYZIN is set
    self.findChild(QtGui.QWidget,'gesamt').setEnabled(self.container.inputData.XYZIN.isSet())
</pre>
<p>Note that the <i>findChild()</i> method is used to get a reference to the launch button. The launch button has been created with its object name set to the name of the task to be launched and this is the second argument to <i>findChild()</i>.</p>
<p>You should also implement an <i>updateLauchButton()</i> method which will be called twice: firstly when the child task window is created and the input <i>status</i> value is 1 (Pending - see top of <a href="../../dbapi/CCP4DbApi.py">dbapi/CCP4DbApi.py</a> file) and then when the job has finished so status is 6 (Finished) or 5 (Failed). Both calls also pass the <i>jobId</i> but only the first call passes the a reference to the new task widget; beware the task widget may have been closed by the time the job finishes.  The example code shows how to copy data from the current task wigdet into the newly launched task widget and then how to get information on job output files from the database in order to use it in the current gui.</p>

<pre>
  def handleLaunchedJob(self,jobId=None,status=None,taskWidget=None):
    # If this is called with status=1=Pending the taskWidget (gesamt window) has just been opened
    # and we can set a value in it
    if status == 1 and taskWidget is not None:
      taskWidget.container.inputData.XYZIN_QUERY.set(self.container.inputData.XYZIN)
    # Status is 6 (Finished)
    elif status == 6:
      # Can not assume that the gesamt widget is still there - must instead query the database for output file
      # Use CDbApi.getJobFilesInfo() which returns a list of dicts containing description of files output by the job
      # The best way to set the file object ot a new value is by setDbFileId()
      from core import CCP4Modules
      gesamtFileList = CCP4Modules.PROJECTSMANAGER().db().getJobFilesInfo(jobId=jobId,jobParamName='XYZOUT')
      if len(gesamtFileList)>0:
        self.getWidget('XYZIN').model.setDbFileId(gesamtFileList[0]['fileId'])
 </pre>

<p>There are some possible problems that are not trapped here - what if the user changes the <i>XYZIN</i> in the current gui but still runs the <i>gesamt</i> task? An exercise for the reader perhaps?<p>


<a name="speedup"><h3>Speeding drawing of tasks</h3>
<p>Complex task inputs take a significant amount of time to draw which
can be reduced by drawing only the top 'Data input' tab when the task
is opened and drawing other tabs on demand.  To implement this the
<i>openFolder()</i> call should have a <i>drawFolder</i> argument that
is the method to draw the contents of the folder.  So in the aimless
task:

<pre>

    def drawContents(self):
  
        self.openFolder(folderFunction='inputData',title='Input Data')
        #define the Input data folder here

        self.openFolder(title='Important Options',drawFolder=self.drawImportant)

        self.openFolder(title='AdditionaOptions',drawFolder=self.drawAdditional)


    def drawImportant(self):
        #define the 'Important Options' folder here
      

    def drawAdditional(self):
        #define the 'Additional Options' folder here

</pre>
<p>There are likely to be additional issues:
<br/>Code to
initialise gui status may need to be put in an appropriate
<i>drawFolder</i> method.
<br/>It may be necessary to test whether a given widget is already drawn by calling
<i>CTaskWidget.getWidget(PARAMNAME)</i> which wil return <i>None</i>
if the widget for <i>PARAMNAME</i> is not yet drawn.
</br/>There are potential problems if the 'toggle' status
(visible/invisible) of a line or subfolder is dependent on parameters
in another folder other than the top 'Input data' folder. This is not
a nice feature anyway.
</p>

