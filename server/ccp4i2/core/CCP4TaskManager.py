import os
import json
from typing import List, Dict, Any, Optional, Type, Tuple
from pathlib import Path

import sys
import subprocess
import argparse


# Module ordering and titles matching legacy CCP4TaskManager
MODULE_ORDER = [
    'data_entry', 'data_processing', 'data_reduction', 'bigpipes', 'alpha_fold',
    'expt_phasing', 'bioinformatics', 'molecular_replacement', 'density_modification',
    'model_building', 'refinement', 'ligands', 'validation', 'export',
    'expt_data_utility', 'model_data_utility', 'developer_tools', 'preferences',
    'wrappers', 'test'
]

MODULE_TITLES = {
    'data_entry': 'Import merged data, AU contents, alignments or coordinates',
    'bigpipes': 'Data to complete structure solution including ligand fitting',
    'data_processing': 'Integrate X-ray images',
    'data_reduction': 'X-ray data reduction and analysis',
    'alpha_fold': 'AlphaFold and RoseTTAFold Utilities',
    'expt_phasing': 'Experimental phasing',
    'bioinformatics': 'Bioinformatics including model preparation for Molecular Replacement',
    'molecular_replacement': 'Molecular Replacement',
    'density_modification': 'Density modification',
    'model_building': 'Model building and Graphics',
    'refinement': 'Refinement',
    'ligands': 'Ligands',
    'validation': 'Validation and analysis',
    'export': 'Export and Deposition',
    'expt_data_utility': 'Reflection data tools',
    'model_data_utility': 'Coordinate data tools',
    'developer_tools': 'Developer tools',
    'preferences': 'Preferences',
    'wrappers': 'Wrappers',
    'demo': 'Demo code for developers only',
    'test': 'Test code for developers only',
    'deprecated': 'Deprecated tasks',
}

# Default tasks to show in each module (these will be shown first if available)
MODULE_DEFAULTS = {
    'molecular_replacement': ['mrbump_basic', 'phaser_simple', 'phaser_pipeline', 'molrep_pipe', 'molrep_den', 'csymmatch', 'parrot', 'phaser_rnp_pipeline'],
    'data_reduction': ['aimless_pipe', 'freerflag', 'matthews', 'molrep_selfrot'],
    'data_entry': ['import_merged', 'ProvideAsuContents', 'ProvideSequence', 'ProvideAlignment'],
    'data_processing': ['xia2_dials', 'xia2_xds', 'imosflm'],
    'expt_phasing': ['crank2', 'shelx', 'phaser_EP_AUTO'],
    'alpha_fold': ['ccp4mg_edit_model', 'mrparse', 'editbfac'],
    'refinement': ['servalcat_pipe', 'prosmart_refmac'],
    'bioinformatics': ['ccp4mg_edit_model', 'ccp4mg_edit_nomrbump', 'chainsaw', 'sculptor', 'phaser_ensembler', 'clustalw'],
    'bigpipes': ['SubstituteLigand', 'dr_mr_modelbuild_pipeline'],
    'model_building': ['modelcraft', 'coot_rebuild', 'coot_script_lines', 'coot_find_waters', 'arp_warp_classic', 'shelxeMR', 'dr_mr_modelbuild_pipeline'],
    'validation': ['validate_protein', 'edstats', 'privateer', 'qtpisa'],
    'export': ['PrepareDeposit'],
    'expt_data_utility': ['pointless_reindexToMatch', 'phaser_EP_LLG', 'cmapcoeff', 'chltofom', 'cphasematch', 'ctruncate', 'splitMtz', 'scaleit'],
    'model_data_utility': ['csymmatch', 'gesamt', 'coordinate_selector', 'qtpisa'],
    'developer_tools': [],
}


# Icon lookup for module folders
MODULE_ICONS = {
    'data_entry': 'qticons/import_merged.png',
    'data_processing': 'qticons/xia2_dials.png',
    'data_reduction': 'qticons/aimless_pipe.png',
    'bigpipes': 'qticons/ccp4i2.png',
    'alpha_fold': 'qticons/mrparse.png',
    'expt_phasing': 'qticons/crank2.png',
    'bioinformatics': 'qticons/chainsaw.png',
    'molecular_replacement': 'qticons/phaser_simple.png',
    'density_modification': 'qticons/parrot.png',
    'model_building': 'qticons/coot_rebuild.png',
    'refinement': 'qticons/refmac.png',
    'ligands': 'qticons/acedrg.png',
    'validation': 'qticons/validate_protein.png',
    'export': 'qticons/export.png',
    'expt_data_utility': 'qticons/pointless.png',
    'model_data_utility': 'qticons/gesamt.png',
    'developer_tools': 'qticons/ccp4i2.png',
    'preferences': 'qticons/ccp4i2.png',
    'wrappers': 'qticons/ccp4i2.png',
    'test': 'qticons/ccp4i2.png',
    'demo': 'qticons/ccp4i2.png',
    'deprecated': 'qticons/ccp4i2.png',
}


# Tasks with autogenerated interfaces (generated from legacy .def.xml GUI files)
# These interfaces are located in client/renderer/components/task/task-interfaces/generated/
# and are auto-generated from the original Qt/XML GUI definitions
AUTOGENERATED_TASKS = {
    'AMPLE', 'AcedrgLink', 'AlternativeImportXIA2', 'LidiaAcedrg',
    'MakeLink', 'MakeProjectsAndDoLigandPipeline', 'PrepareDeposit',
    'ProvideAlignment', 'SIMBAD', 'ShelxCD', 'SubtractNative',
    'TestObsConversions', 'add_fractional_coords', 'adding_stats_to_mmcif_i2',
    'arcimboldo', 'ccp4mg_edit_model', 'ccp4mg_edit_nomrbump', 'ccp4mg_general',
    'chltofom', 'cmapcoeff', 'comit', 'coordinate_selector', 'coot1',
    'coot_rebuild', 'coot_rsr_morph', 'cpatterson', 'ctruncate', 'density_calculator',
    'dr_mr_modelbuild_pipeline', 'editbfac', 'i2Dimple', 'import_mosflm',
    'lorestr_i2', 'mergeMtz', 'metalCoord', 'modelASUCheck', 'morda_i2',
    'mosflm', 'pdb_redo_api', 'pdbview_edit',
    'phaser_ensembler', 'phaser_phil', 'pisapipe', 'pointless_reindexToMatch',
    'privateer', 'qtpisa', 'sheetbend', 'validate_protein', 'xia2_dials',
    'xia2_multiplex', 'xia2_ssx_reduce', 'zanuda'
}


class CTaskManager:
    insts = None

    def __init__(self):
        self.task_manager_dir = Path(__file__).parent / "task_manager"
        defxml_path = self.task_manager_dir / "defxml_lookup.json"
        plugin_path = self.task_manager_dir / "plugin_lookup.json"
        task_module_path = self.task_manager_dir / "task_module_map.json"
        task_metadata_path = self.task_manager_dir / "task_metadata.json"

        self.defxml_lookup: List[Dict[str, str]] = []
        self.plugin_lookup: Dict[str, Dict[str, Any]] = {}
        self.task_module_map: Dict[str, str] = {}
        self.task_metadata: Dict[str, Dict[str, Any]] = {}

        try:
            with defxml_path.open(encoding="utf-8") as f:
                self.defxml_lookup = json.load(f)
        except Exception as e:
            print(f"Error loading defxml_lookup.json: {e}")

        # Load plugin_lookup.json (for backward compatibility)
        try:
            with plugin_path.open(encoding="utf-8") as f:
                self.plugin_lookup = json.load(f)
        except Exception as e:
            print(f"Error loading plugin_lookup.json: {e}")

        # Load task_module_map.json (task-to-folder mapping for UI)
        try:
            with task_module_path.open(encoding="utf-8") as f:
                data = json.load(f)
                # Remove _comment key if present
                self.task_module_map = {k: v for k, v in data.items() if not k.startswith('_')}
        except Exception as e:
            print(f"Error loading task_module_map.json: {e}")

        # Load task_metadata.json (UI display metadata: titles, descriptions, etc.)
        try:
            with task_metadata_path.open(encoding="utf-8") as f:
                data = json.load(f)
                # Remove _comment/_todo keys if present
                self.task_metadata = {k: v for k, v in data.items() if not k.startswith('_')}
        except Exception as e:
            print(f"Error loading task_metadata.json: {e}")

        # Initialize plugin and report registries (lazy loading)
        self._plugin_registry = None
        self._report_registry = None

    @property
    def plugin_registry(self):
        """Get the plugin registry (lazy load on first access)."""
        if self._plugin_registry is None:
            from .task_manager.plugin_registry import get_registry
            self._plugin_registry = get_registry()
        return self._plugin_registry

    @property
    def report_registry(self):
        """Get the report registry (lazy load on first access)."""
        if self._report_registry is None:
            from .task_manager.report_registry import get_report_registry
            self._report_registry = get_report_registry()
        return self._report_registry

    def get_plugin_class(self, task_name: str, version: Optional[str] = None) -> Optional[Type]:
        """
        Get a plugin class by name, with lazy loading.

        Args:
            task_name: Name of the task/plugin (e.g., "refmac", "pointless")
            version: Optional version (currently ignored - uses latest)

        Returns:
            Plugin class, or None if not found
        """
        return self.plugin_registry.get_plugin_class(task_name, version)

    def get_plugin_metadata(self, task_name: str) -> Optional[Dict[str, Any]]:
        """
        Get plugin metadata without importing the plugin.

        Args:
            task_name: Name of the task/plugin

        Returns:
            Dictionary of plugin metadata, or None if not found
        """
        return self.plugin_registry.get_plugin_metadata(task_name)

    def list_plugins(self) -> List[str]:
        """Get list of all available plugin names."""
        return self.plugin_registry.list_plugins()

    def locate_def_xml(self, task_name: str, version: Optional[str] = None) -> Optional[Path]:
        """
        Locate the .def.xml file for a task given its name.

        Args:
            task_name: Name of the task/plugin (e.g., "refmac", "pointless")
            version: Optional version (IGNORED - kept for API compatibility, but unused since
                     no plugins in this codebase actually have multiple versions)

        Returns:
            Path to the .def.xml file if found, None otherwise
        """
        # CRITICAL: Paths in defxml_lookup.json are relative to the task_manager directory
        # (where defxml_lookup.py is located), NOT relative to CCP4I2_ROOT or CWD.
        #
        # The defxml_lookup.py script does:
        #   script_dir = os.path.dirname(os.path.abspath(__file__))  # core/task_manager/
        #   rel_path = os.path.relpath(file_path, script_dir)
        #
        # So a path like "../../pipelines/shelx/script/shelx.def.xml" means:
        #   - Start from core/task_manager/
        #   - Go up two levels to project root
        #   - Then pipelines/shelx/script/shelx.def.xml
        #
        # Therefore, we resolve relative to self.task_manager_dir (which is rooted to
        # __file__, making it CWD-independent)
        rel_path = self.defxml_lookup.get(task_name)
        if rel_path:
            abs_path = self.task_manager_dir / rel_path
            abs_path = abs_path.resolve()  # Resolve any .. in the path
            if abs_path.exists():
                return abs_path
        return None

    def getReportClass(self, name: str, version: Optional[str] = None) -> Optional[Type]:
        """
        Get the report class for a plugin/task.

        Uses the report registry which discovers *_report.py files in wrappers/,
        wrappers2/, and pipelines/ directories.

        Args:
            name: Name of the task/plugin (e.g., "refmac", "pointless")
            version: Optional version string (currently ignored)

        Returns:
            Report class if found, None otherwise
        """
        return self.report_registry.get_report_class(name, version)

    def get_report_metadata(self, name: str) -> Optional[Dict[str, Any]]:
        """
        Get report metadata without importing the report class.

        Args:
            name: Name of the task/plugin (e.g., "refmac", "pointless")

        Returns:
            Dictionary of report metadata (RUNNING, WATCHED_FILE, etc.), or None if not found
        """
        return self.report_registry.get_report_metadata(name)

    def has_report(self, name: str) -> bool:
        """
        Check if a report class exists for a task name.

        Args:
            name: Name of the task/plugin

        Returns:
            True if a report class exists, False otherwise
        """
        return self.report_registry.has_report(name)

    def list_reports(self) -> List[str]:
        """Get list of all available report task names."""
        return self.report_registry.list_reports()

    def searchPath(self) -> List[str]:
        """
        Get the search path for plugins (wrappers, pipelines, etc.).

        Returns:
            List of directory paths containing plugin scripts
        """
        ccp4i2_root = os.environ.get("CCP4I2_ROOT", os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
        return [
            os.path.join(ccp4i2_root, "wrappers", "*", "script"),
            os.path.join(ccp4i2_root, "wrappers2", "*", "script"),
            os.path.join(ccp4i2_root, "pipelines", "*", "script"),
            os.path.join(ccp4i2_root, "pipelines", "*", "wrappers", "*", "script"),
        ]

    def searchReferenceFile(self, name: Optional[str] = None, version: Optional[str] = None,
                           cformat: str = 'medline', drillDown: bool = False) -> List[str]:
        """
        Search for reference/bibliography files for a task.

        Reference files are typically .medline.txt files containing citation information.

        Args:
            name: Name of the task/plugin (e.g., "refmac", "servalcat_pipe")
            version: Optional version (currently ignored)
            cformat: Format of reference file (default "medline")
            drillDown: If True, also search for reference files in subtasks

        Returns:
            List of file paths to reference files found
        """
        import glob

        if name is None:
            return []

        file_list = []
        search_pattern = f"{name}.{cformat}.txt"

        # Search all paths in the search path
        for path_pattern in self.searchPath():
            # Expand the glob pattern in the path (e.g., wrappers/*/script)
            matching_dirs = glob.glob(path_pattern)
            for directory in matching_dirs:
                full_path = os.path.join(directory, search_pattern)
                if os.path.exists(full_path):
                    file_list.append(full_path)

        if drillDown:
            # Get subtasks from plugin metadata
            metadata = self.get_plugin_metadata(name)
            if metadata:
                sub_tasks = metadata.get('subTasks', [])
                for sub_task in sub_tasks:
                    file_list.extend(self.searchReferenceFile(name=sub_task, cformat=cformat, drillDown=True))

        return file_list

    def getReportAttribute(self, name: str, attribute: str, version: Optional[str] = None) -> Any:
        """
        Get an attribute from a plugin's report class or metadata.

        Tries to get the attribute from cached metadata first (fast, no import).
        Falls back to importing the report class if the attribute is not in metadata.

        Args:
            name: Name of the task/plugin (e.g., "refmac", "pointless")
            attribute: Name of the attribute to retrieve (e.g., "WATCHED_FILE")
            version: Optional version string (currently ignored)

        Returns:
            Attribute value if found, None otherwise
        """
        # First try to get from metadata (fast, no import required)
        metadata = self.get_report_metadata(name)
        if metadata and attribute in metadata:
            return metadata[attribute]

        # Fall back to importing the class for non-metadata attributes
        report_class = self.getReportClass(name, version)
        if report_class is None:
            return None

        return getattr(report_class, attribute, None)

    def getTitle(self, name: str) -> Optional[str]:
        """
        Get the title of a plugin/task.

        Args:
            name: Name of the task/plugin (e.g., "refmac", "pointless")

        Returns:
            Task title if found, None otherwise
        """
        metadata = self.get_plugin_metadata(name)
        if metadata:
            return metadata.get("TASKTITLE")
        return None

    def getShortTitle(self, name: str) -> Optional[str]:
        """
        Get the short title of a plugin/task. Falls back to TASKNAME if no short title available.

        Args:
            name: Name of the task/plugin (e.g., "refmac", "pointless")

        Returns:
            Task short title or task name if found, None otherwise
        """
        metadata = self.get_plugin_metadata(name)
        if metadata:
            # Try SHORTTITLE first, fall back to TASKNAME
            return metadata.get("SHORTTITLE", metadata.get("TASKNAME"))
        return None

    def _normalize_module_name(self, module: Any) -> str:
        """
        Normalize module name to match MODULE_ORDER keys.

        Handles:
        - Lists (take first element)
        - Spaces vs underscores
        - None values
        """
        if module is None:
            return 'wrappers'

        # Handle lists (some tasks have multiple modules)
        if isinstance(module, list):
            module = module[0] if module else 'wrappers'

        # Normalize spaces to underscores
        module = str(module).replace(' ', '_').lower()

        return module

    def _get_task_module(self, task_name: str, metadata: Dict[str, Any]) -> str:
        """
        Get the module for a task, using task_module_map.json as the primary source.

        Priority:
        1. task_module_map.json (canonical mapping from CCP4 GUI widgets)
        2. TASKMODULE from plugin metadata
        3. Default to 'wrappers'
        """
        # First check our canonical mapping (derived from GUI widget classes)
        if task_name in self.task_module_map:
            return self.task_module_map[task_name]

        # Fall back to metadata TASKMODULE (rarely set in plugin scripts)
        module = metadata.get('TASKMODULE')
        return self._normalize_module_name(module)

    def _build_module_lookup(self) -> Dict[str, List[str]]:
        """
        Build a mapping of module names to task lists.

        Returns:
            Dict mapping module name to list of task names
        """
        module_lookup: Dict[str, List[str]] = {}

        for task_name, metadata in self.plugin_lookup.items():
            module = self._get_task_module(task_name, metadata)

            if module not in module_lookup:
                module_lookup[module] = []

            module_lookup[module].append(task_name)

        # Sort tasks within each module, putting defaults first
        for module_name, task_list in module_lookup.items():
            defaults = MODULE_DEFAULTS.get(module_name, [])
            # Put default tasks first (in order), then remaining tasks alphabetically
            default_tasks = [t for t in defaults if t in task_list]
            other_tasks = sorted([t for t in task_list if t not in defaults])
            module_lookup[module_name] = default_tasks + other_tasks

        return module_lookup

    def task_tree(self, show_wrappers: bool = False) -> List[Tuple[str, str, List[str]]]:
        """
        Generate the task tree structure for the frontend.

        Returns a list of tuples: (module_name, module_title, task_names_list)

        Args:
            show_wrappers: If True, include wrappers/test/demo modules

        Returns:
            List of [module_name, module_title, [task_names...]] tuples
        """
        module_lookup = self._build_module_lookup()
        tree = []

        # Main modules (always shown)
        hidden_modules = {'preferences', 'test', 'demo', 'wrappers', 'deprecated'}

        for module in MODULE_ORDER:
            if module in hidden_modules and not show_wrappers:
                continue

            if module in module_lookup and module_lookup[module]:
                title = MODULE_TITLES.get(module, module)
                task_list = module_lookup[module]
                tree.append((module, title, task_list))

        # Include any modules not in MODULE_ORDER
        for module_name in sorted(module_lookup.keys()):
            if module_name not in MODULE_ORDER:
                if module_name in hidden_modules and not show_wrappers:
                    continue
                title = MODULE_TITLES.get(module_name, module_name)
                tree.append((module_name, title, module_lookup[module_name]))

        return tree

    @property
    def task_lookup(self) -> Dict[str, Dict[str, Any]]:
        """
        Generate the task lookup structure for the frontend.

        Returns a nested dict: {taskName: {metadata...}}

        The frontend expects this structure for displaying task cards:
        - TASKTITLE: Full title
        - taskName: Internal task name
        - DESCRIPTION: Task description
        - MAINTAINER: Maintainer name
        - shortTitle: Short title for display

        Metadata is merged from multiple sources with priority:
        1. task_metadata.json (extracted from GUI widgets - has descriptions)
        2. plugin_lookup.json (extracted from plugin scripts)
        3. Defaults
        """
        lookup: Dict[str, Dict[str, Any]] = {}

        for task_name, plugin_meta in self.plugin_lookup.items():
            # Get rich metadata from task_metadata.json (extracted from GUI widgets)
            ui_meta = self.task_metadata.get(task_name, {})

            # Merge metadata with priority: ui_meta > plugin_meta > defaults
            lookup[task_name] = {
                'TASKTITLE': ui_meta.get('TASKTITLE') or plugin_meta.get('TASKTITLE') or task_name,
                'taskName': task_name,
                'DESCRIPTION': ui_meta.get('DESCRIPTION') or plugin_meta.get('DESCRIPTION') or '',
                'MAINTAINER': ui_meta.get('MAINTAINER') or plugin_meta.get('MAINTAINER') or 'Nobody',
                'shortTitle': ui_meta.get('shortTitle') or plugin_meta.get('SHORTTASKTITLE') or plugin_meta.get('TASKTITLE') or task_name,
                'isAutogenerated': task_name in AUTOGENERATED_TASKS,
            }

        return lookup

    @property
    def task_icon_lookup(self) -> Dict[str, str]:
        """
        Return icon paths for module folders.

        Returns:
            Dict mapping module name to icon path (relative to static dir)
        """
        return MODULE_ICONS.copy()


def TASKMANAGER():
    """Return a unique instance of CTaskManager."""
    if CTaskManager.insts is None:
        CTaskManager.insts = CTaskManager()
    return CTaskManager.insts


def main():
    """Main entry point for module. Use --rebuild to regenerate lookup files."""
    parser = argparse.ArgumentParser(description="CCP4 Task Manager Utility")
    parser.add_argument(
        "--rebuild", action="store_true", help="Regenerate lookup files"
    )
    args = parser.parse_args()

    if args.rebuild:
        dir_path = os.path.dirname(os.path.abspath(__file__))
        defxml_script = os.path.join(dir_path, "task_manager", "defxml_lookup.py")
        plugin_script = os.path.join(dir_path, "task_manager", "plugin_lookup.py")
        report_script = os.path.join(dir_path, "task_manager", "report_lookup.py")

        print("Regenerating defxml_lookup.json...")
        subprocess.run([sys.executable, defxml_script], check=True)
        print("Regenerating plugin_lookup.json and plugin_registry.py...")
        subprocess.run([sys.executable, plugin_script], check=True)
        print("Regenerating report_lookup.json and report_registry.py...")
        subprocess.run([sys.executable, report_script], check=True)
        print("Lookup files regenerated.")
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
