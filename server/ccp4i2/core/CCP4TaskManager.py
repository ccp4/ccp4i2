from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from .. import I2_TOP
from .task_manager.defxml_lookup import defXmlPaths
from .task_manager.modules import TASK_MODULE_MAP
from .task_manager.plugin_lookup import PLUGIN_LOOKUP
from .task_manager.task_metadata import TASK_METADATA

# Module ordering and titles matching legacy CCP4TaskManager
MODULE_ORDER = [
    'data_entry', 'data_processing', 'data_reduction', 'bigpipes', 'alpha_fold',
    'expt_phasing', 'bioinformatics', 'molecular_replacement', 'density_modification',
    'model_building', 'refinement', 'ligands', 'validation', 'export',
    'expt_data_utility', 'model_data_utility', 'developer_tools', 'preferences',
    'wrappers', 'test'
]

MODULE_TITLES = {
    'data_entry': 'Import merged data, AU contents, alignments or coordinates',
    'bigpipes': 'Data to complete structure solution including ligand fitting',
    'data_processing': 'Integrate X-ray images',
    'data_reduction': 'X-ray data reduction and analysis',
    'alpha_fold': 'AlphaFold and RoseTTAFold Utilities',
    'expt_phasing': 'Experimental phasing',
    'bioinformatics': 'Bioinformatics including model preparation for Molecular Replacement',
    'molecular_replacement': 'Molecular Replacement',
    'density_modification': 'Density modification',
    'model_building': 'Model building and Graphics',
    'refinement': 'Refinement',
    'ligands': 'Ligands',
    'validation': 'Validation and analysis',
    'export': 'Export and Deposition',
    'expt_data_utility': 'Reflection data tools',
    'model_data_utility': 'Coordinate data tools',
    'developer_tools': 'Developer tools',
    'preferences': 'Preferences',
    'wrappers': 'Wrappers',
    'demo': 'Demo code for developers only',
    'test': 'Test code for developers only',
    'deprecated': 'Deprecated tasks',
}

# Default tasks to show in each module (these will be shown first if available)
MODULE_DEFAULTS = {
    'molecular_replacement': ['mrbump_basic', 'phaser_simple', 'phaser_pipeline', 'molrep_pipe', 'molrep_den', 'csymmatch', 'parrot', 'phaser_rnp_pipeline'],
    'data_reduction': ['aimless_pipe', 'freerflag', 'matthews', 'molrep_selfrot'],
    'data_entry': ['import_merged', 'ProvideAsuContents', 'ProvideSequence', 'ProvideAlignment'],
    'data_processing': ['xia2_dials', 'xia2_xds', 'imosflm'],
    'expt_phasing': ['crank2', 'shelx', 'phaser_EP_AUTO'],
    'alpha_fold': ['ccp4mg_edit_model', 'mrparse', 'editbfac'],
    'refinement': ['servalcat_pipe', 'prosmart_refmac'],
    'bioinformatics': ['ccp4mg_edit_model', 'ccp4mg_edit_nomrbump', 'chainsaw', 'sculptor', 'phaser_ensembler', 'clustalw'],
    'bigpipes': ['SubstituteLigand', 'dr_mr_modelbuild_pipeline'],
    'model_building': ['modelcraft', 'coot_rebuild', 'coot_script_lines', 'coot_find_waters', 'arp_warp_classic', 'shelxeMR', 'dr_mr_modelbuild_pipeline'],
    'validation': ['validate_protein', 'edstats', 'privateer', 'qtpisa'],
    'export': ['PrepareDeposit'],
    'expt_data_utility': ['pointless_reindexToMatch', 'phaser_EP_LLG', 'cmapcoeff', 'chltofom', 'cphasematch', 'ctruncate', 'splitMtz', 'scaleit'],
    'model_data_utility': ['csymmatch', 'gesamt', 'coordinate_selector', 'qtpisa'],
    'developer_tools': [],
}


# Icon lookup for module folders
MODULE_ICONS = {
    'data_entry': 'qticons/import_merged.png',
    'data_processing': 'qticons/xia2_dials.png',
    'data_reduction': 'qticons/aimless_pipe.png',
    'bigpipes': 'qticons/ccp4i2.png',
    'alpha_fold': 'qticons/mrparse.png',
    'expt_phasing': 'qticons/crank2.png',
    'bioinformatics': 'qticons/chainsaw.png',
    'molecular_replacement': 'qticons/phaser_simple.png',
    'density_modification': 'qticons/parrot.png',
    'model_building': 'qticons/coot_rebuild.png',
    'refinement': 'qticons/refmac.png',
    'ligands': 'qticons/acedrg.png',
    'validation': 'qticons/validate_protein.png',
    'export': 'qticons/export.png',
    'expt_data_utility': 'qticons/pointless.png',
    'model_data_utility': 'qticons/gesamt.png',
    'developer_tools': 'qticons/ccp4i2.png',
    'preferences': 'qticons/ccp4i2.png',
    'wrappers': 'qticons/ccp4i2.png',
    'test': 'qticons/ccp4i2.png',
    'demo': 'qticons/ccp4i2.png',
    'deprecated': 'qticons/ccp4i2.png',
}


# Tasks with autogenerated interfaces (generated from legacy .def.xml GUI files)
# These interfaces are located in client/renderer/components/task/task-interfaces/generated/
# and are auto-generated from the original Qt/XML GUI definitions
AUTOGENERATED_TASKS = {
    'AMPLE', 'AcedrgLink', 'AlternativeImportXIA2', 'LidiaAcedrg',
    'MakeLink', 'MakeProjectsAndDoLigandPipeline', 'PrepareDeposit',
    'ProvideAlignment', 'SIMBAD', 'ShelxCD', 'SubtractNative',
    'TestObsConversions', 'add_fractional_coords', 'adding_stats_to_mmcif_i2',
    'arcimboldo', 'ccp4mg_edit_model', 'ccp4mg_edit_nomrbump', 'ccp4mg_general',
    'chltofom', 'cmapcoeff', 'comit', 'coordinate_selector', 'coot1',
    'coot_rebuild', 'coot_rsr_morph', 'cpatterson', 'ctruncate', 'density_calculator',
    'dr_mr_modelbuild_pipeline', 'editbfac', 'i2Dimple', 'import_mosflm',
    'lorestr_i2', 'mergeMtz', 'metalCoord', 'modelASUCheck', 'morda_i2',
    'mosflm', 'pdb_redo_api', 'pdbview_edit',
    'phaser_ensembler', 'phaser_phil', 'pisapipe', 'pointless_reindexToMatch',
    'privateer', 'qtpisa', 'sheetbend', 'validate_protein', 'xia2_dials',
    'xia2_multiplex', 'xia2_ssx_reduce', 'zanuda'
}


def locate_def_xml(task_name: str) -> Optional[Path]:
    """
    Locate the .def.xml file for a task given its name.

    Args:
        task_name: Name of the task/plugin (e.g., "refmac", "pointless")

    Returns:
        Path to the .def.xml file if found, None otherwise
    """
    rel_path = defXmlPaths.get(task_name)  # relative to I2_TOP
    if rel_path:
        abs_path = (I2_TOP / rel_path).resolve()
        if abs_path.exists():
            return abs_path
    return None


def _build_module_lookup() -> Dict[str, List[str]]:
    """
    Build a mapping of module names to task lists.

    Returns:
        Dict mapping module name to list of task names
    """
    module_lookup: Dict[str, List[str]] = {}

    for task_name, metadata in PLUGIN_LOOKUP.items():
        module = TASK_MODULE_MAP.get(task_name, "wrappers")

        if module not in module_lookup:
            module_lookup[module] = []

        module_lookup[module].append(task_name)

    # Sort tasks within each module, putting defaults first
    for module_name, task_list in module_lookup.items():
        defaults = MODULE_DEFAULTS.get(module_name, [])
        # Put default tasks first (in order), then remaining tasks alphabetically
        default_tasks = [t for t in defaults if t in task_list]
        other_tasks = sorted([t for t in task_list if t not in defaults])
        module_lookup[module_name] = default_tasks + other_tasks

    return module_lookup


def _task_tree(show_wrappers: bool = False) -> List[Tuple[str, str, List[str]]]:
    """
    Generate the task tree structure for the frontend.

    Returns a list of tuples: (module_name, module_title, task_names_list)

    Args:
        show_wrappers: If True, include wrappers/test/demo modules

    Returns:
        List of [module_name, module_title, [task_names...]] tuples
    """
    module_lookup = _build_module_lookup()
    tree = []

    # Main modules (always shown)
    hidden_modules = {'preferences', 'test', 'demo', 'wrappers', 'deprecated'}

    for module in MODULE_ORDER:
        if module in hidden_modules and not show_wrappers:
            continue

        if module in module_lookup and module_lookup[module]:
            title = MODULE_TITLES.get(module, module)
            task_list = module_lookup[module]
            tree.append((module, title, task_list))

    # Include any modules not in MODULE_ORDER
    for module_name in sorted(module_lookup.keys()):
        if module_name not in MODULE_ORDER:
            if module_name in hidden_modules and not show_wrappers:
                continue
            title = MODULE_TITLES.get(module_name, module_name)
            tree.append((module_name, title, module_lookup[module_name]))

    return tree


def _task_lookup() -> Dict[str, Dict[str, Any]]:
    """
    Generate the task lookup structure for the frontend.

    Returns a nested dict: {taskName: {metadata...}}

    The frontend expects this structure for displaying task cards:
    - TASKTITLE: Full title
    - taskName: Internal task name
    - DESCRIPTION: Task description
    - shortTitle: Short title for display

    Metadata is merged from multiple sources with priority:
    1. TASK_METADATA (extracted from GUI widgets - has descriptions)
    2. PLUGIN_LOOKUP (extracted from plugin scripts)
    3. Defaults
    """
    lookup: Dict[str, Dict[str, Any]] = {}

    for task_name, plugin_meta in PLUGIN_LOOKUP.items():
        # Get rich metadata from TASK_METADATA (extracted from GUI widgets)
        ui_meta = TASK_METADATA.get(task_name, {})

        # Merge metadata with priority: ui_meta > plugin_meta > defaults
        lookup[task_name] = {
            'TASKTITLE': ui_meta.get('TASKTITLE') or plugin_meta.get('TASKTITLE') or task_name,
            'taskName': task_name,
            'DESCRIPTION': ui_meta.get('DESCRIPTION') or plugin_meta.get('DESCRIPTION') or '',
            'shortTitle': ui_meta.get('shortTitle') or plugin_meta.get('SHORTTASKTITLE') or plugin_meta.get('TASKTITLE') or task_name,
            'isAutogenerated': task_name in AUTOGENERATED_TASKS,
        }

    return lookup


def get_task_tree():
    """
    Build the task tree structure for the frontend.

    Returns:
        Dict with:
        - tree: List of [module_name, module_title, [task_names...]] tuples
        - lookup: Dict mapping taskName -> {version: {metadata...}}
        - iconLookup: Dict mapping module name to icon path
    """
    result = {
        "tree": _task_tree(),
        "lookup": _task_lookup(),
        "iconLookup": MODULE_ICONS,
    }
    return result
